LeetCode çªå‡»æ‰‹å†Œ
======


1 ä»æ•°ç»„ä¸­æ‰¾å‡ºä¸¤ä¸ªæ•°å­—ä½¿å¾—ä»–ä»¬çš„å’Œæ˜¯ç»™å®šçš„æ•°å­—
------

ä½¿ç”¨ä¸€ä¸ªæ•£åˆ—, å­˜å‚¨æ•°å­—å’Œä»–å¯¹åº”çš„ç´¢å¼•ã€‚ç„¶åéå†æ•°ç»„, å¦‚æœå¦ä¸€åŠåœ¨æ•£åˆ—å½“ä¸­, é‚£ä¹ˆè¿”å›
è¿™ä¸¤ä¸ªæ•°çš„ç´¢å¼•, ç¨‹åºç»“æŸï¼›å¦‚æœä¸åœ¨, æŠŠå½“å‰æ•°å­—åŠ å…¥åˆ°æ•£åˆ—ä¸­ã€‚

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> hash;
    vector<int> result(2);
    for (int i = 0; i != nums.size(); ++i) {
        int reminder = target - nums[i];
        if (hash.find(reminder) != hash.end()) {
            result[0] = hash[reminder] + 1;
            result[1] = i + 1;
            return result;
        }
        hash[nums[i]] = i;
    }
    return result;
}
```

```Python
class Solution:
    # @return a tuple, (index1, index2)
     def twoSum(self, num, target):
         possible_answers = {}
         for i in range(len(num)):
             if num[i] in possible_answers:
                 return possible_answers[num[i]] + 1, i + 1
             else:
                 possible_answers[target - num[i]] = i
```

Follow up: å¦‚æœæ•°ç»„æ˜¯å·²ç»æ’åºçš„å‘¢ï¼Ÿ

```C++
sort(nums.begin(), nums.end()) // å‡è®¾å·²ç»æ’åºï¼Œåªæœ‰ä¸€ä¸ªç»“æœ
pair<int> twoSum(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int s = nums[left] + nums[right];
        if (s == target)
            return make_pair(left, right);
        else if (s < sum)
            left++;
        else
            right--;
    }
}
```

2 ç»™ä¸¤ä¸ªåˆ—è¡¨, æ•°å­—åœ¨å…¶ä¸­æŒ‰ä½ä½åˆ°é«˜ä½å­˜å‚¨, æ±‚ä»–ä»¬çš„å’Œ
------

ç›´æ¥è¿­ä»£éå†æ•°ç»„, è€ƒå¯Ÿç»†èŠ‚æ“ä½œã€‚æ³¨æ„ dummy head çš„ä½¿ç”¨ã€‚

```C
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode dummy, *p = &dummy;
    int carry = 0;
    // æ³¨æ„æœ€åå¦‚æœæœ‰ carry çš„è¯ï¼Œéœ€è¦å†ç”Ÿæˆä¸€ä¸ªèŠ‚ç‚¹
    while (l1 || l2 || carry) {
        int v1 = l1 ? l1->val: 0;
        int v2 = l2 ? l2->val: 0;
        int v = v1 + v2 + carry;
        p->next = malloc(sizeof(struct ListNode));
        p = p->next;
        p->val = v % 10;
        p->next = NULL;
        carry = v / 10;

        l1 = l1 ? l1->next: NULL;
        l2 = l2 ? l2->next: NULL;
    }
    return dummy.next;
}
```

```C++
class Solution {
    public:
        ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
            if (l1 == NULL) return l2;
            if (l2 == NULL) return l1;
            int shift = 0;
            ListNode* result = new ListNode(0);
            ListNode* p = result;
            while (l1 != NULL || l2 != NULL) {
                ListNode* newNode = new ListNode(0);
                int v1 = l1 != NULL ? l1->val : 0;
                int v2 = l2 != NULL ? l2->val : 0;
                newNode->val = v1 + v2 + shift;
                if (newNode->val > 9) {
                    newNode->val -= 10;
                    shift = 1;
                } else {
                    shift = 0;
                }
                if (l1) {
                    l1 = l1->next;
                }
                if (l2) {
                    l2 = l2->next;
                }
                p->next = newNode;
                p = p->next;
            }
            // æ³¨æ„æœ€åå¤šä½™çš„ä¸€ä¸ªè¿›ä½å¤„ç†
            if (shift == 1) {
                p->next = new ListNode(1);
            }
            return result->next;
        }
};
```

3 æœ€é•¿ä¸é‡å¤å­ä¸²
------

ä½¿ç”¨åŠ¨æ€è§„åˆ’, åœ¨ä¸€ä¸ª Hash ä¸­å­˜å‚¨å·²ç»å‡ºç°çš„å­—ç¬¦çš„ä¸Šä¸€æ¬¡å‡ºç°çš„ç´¢å¼•å€¼, å¦‚æœç´¢å¼•å€¼
å­˜åœ¨, åˆ™æŠŠå½“å‰æœ€é•¿å­ä¸²çš„å·¦è¾¹ç•Œæ›´æ–°ä¸ºè¯¥ç´¢å¼•å€¼ã€‚

æ³¨æ„, å½“å­—ç¬¦æœ‰é™çš„æ—¶å€™, æ¯”å¦‚é™å®šä¸º ASCII å­—ç¬¦, å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ä»£æ›¿ Hashã€‚

```C

int lengthOfLongestSubstring(char* s) {
    int indices[256];
    for (int i = 0; i < 256; i++)  // init the array, memset can only be used for char
        indices[i] = -1;
    int left = 0;
    int longest = 0;

    for (int i = 0; s[i] != '\0'; i++) {
        left = max(left, indices[s[i]] + 1);   // è€ƒè™‘æ–°åŠ å…¥å­—ç¬¦åå¯¹å·¦è¾¹ç•Œçš„å½±å“
        indices[s[i]] = i;                     // æ›´æ–°å…ƒç´ ä¸Šæ¬¡å‡ºç°ä½ç½®
        longest = max(longest, i - left + 1);  // åº”ç”¨åŠ¨æ€è§„åˆ’
    }
    return longest;
}
```

4 æ‰¾åˆ°ä¸¤ä¸ªæ’åºæ•°ç»„çš„ä¸­ä½æ•°
------

è§£æ³•å‚è§[è¿™é‡Œ](https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation)

ä½¿ç”¨ä¸¤ä¸ªæ•°å­— i å’Œ j, åˆ†åˆ«ä½œä¸º AB çš„åˆ†éš”å…ƒç´ , æŠŠ AB åˆ†æˆä¸¤ä»½ï¼Œ æ¯”å¦‚ 
`A[0..i]`, `B[0..j]` å’Œ `A[i, m]`, `B[j, n]`ï¼Œè¿™æ ·æˆ‘ä»¬åªéœ€è¦ä¸‹é¢ä¸¤ä¸ªæ¡ä»¶å°±å¯ä»¥äº†:

* `i+j = m-i + n-j`, ä¹Ÿå°±æ˜¯ `i+j = (m+n)/2`
* `B[j-1] <= A[i] && A[i-1] <= B[j]`,  Bçš„å‰ä¸€åŠå…ƒç´ å°äºAçš„åˆ†éš”ç¬¦, Açš„å‰ä¸€åŠå…ƒç´ å°äºBçš„åˆ†éš”ç¬¦

è¿™æ—¶å€™æˆ‘ä»¬å°±å¾—åˆ°äº† A[i] å°±æ˜¯æˆ‘ä»¬çš„ä¸­ä½æ•°ï¼Œæˆ–è€…ä¹‹ä¸€ã€‚ i çš„åˆå§‹å€¼åœ¨ 0 åˆ° m ä¹‹é—´ï¼Œ
ç„¶åæˆ‘ä»¬äºŒåˆ†æœç´¢ `i = (imin + imax) / 2, j = mid - i`ã€‚

```C
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
double findMedianSortedArrays(int* A, int m, int* B, int n) {
    if (m > n) return findMedianSortedArrays(B, n, A, m);
    int imin = 0, maxidx = m, i, j, num1, mid = (m + n + 1) >> 1, num2;
    while (imin <= maxidx) {
        i = (imin + maxidx) >> 1;
        j = mid - i;
        if (i < m && j > 0 && B[j-1] > A[i])  // Bä¸­çš„æ•°å­—åå¤§
            imin = i + 1;
        else if (i > 0 && j < n && B[j] < A[i-1])  // Aä¸­çš„æ•°å­—åå¤§
            maxidx = i - 1;
        else {
            if (i == 0) num1 = B[j-1];
            else if (j == 0) num1 = A[i - 1];
            else num1 = max(A[i-1],B[j-1]);  // æ™®é€šæƒ…å†µ
            break;
        }
    }
    if ((m + n) & 0x1) // odd
        return num1;
    if (i == m)
        num2 = B[j];
    else if (j == n)
        num2 = A[i];
    else
        num2 = min(A[i], B[j]); // æ™®é€šæƒ…å†µ
    return (num1 + num2) / 2.0; // æ³¨æ„æ•´æ•°é™¤æ³•
}
```

5 æœ€é•¿å›æ–‡å­ä¸²
------

1. ä»¥æŸä¸ªå…ƒç´ ä¸ºä¸­å¿ƒ, å‘ä¸¤è¾¹å±•å¼€, æ³¨æ„å¤„ç†å¥‡æ•°å’Œå¶æ•°ä¸¤ç§æƒ…å†µ
2. Manacher ç®—æ³•, å‚è§[è¿™é‡Œ](http://taop.marchtea.com/01.05.html)

```C
char* longestPalindrome(char* s) {
    if (!s) return NULL;

    int length = 0; // length of the longest palindromic string
    int start = -1; // start of the lonest palidromic string

    int len = strlen(s);
    for (int i = 0; i < len; i++) {

        // length is odd
        for (int j = 0; (i - j >= 0) && (i + j < len); j++) {
            if (s[i - j] != s[i + j])
                break;
            if (j * 2 + 1 > length) {
                length = j * 2 + 1;
                start = i - j;
            }
        }

        // length is even
        for (int j = 0; (i - j >= 0) && (i + j + 1 < len); j++) {
            if (s[i - j] != s[i + j + 1])
                break;
            if (j * 2 + 2 > length) {
                length = j * 2 + 2;
                start = i - j;
            }
        }
    }

    char* result = malloc(sizeof(char) * length + 1);
    strncpy(result, s + start, length);
    result[length] = 0;

    return result;
}
```

6 ZigZag å­—ç¬¦ä¸², æŠŠå­—ç¬¦ä¸²æ°å¼¯, ç„¶åå†æŒ‰è¡Œè¾“å‡º
------

è€ƒå¯Ÿæ•°å­¦, æ‰¾å‡ºè§„å¾‹, æ‰€ä»¥å®é™…ä¸Šå¹¶ä¸æ˜¯ Z å­å½¢ï¼Œè€Œæ˜¯ç”± V ç»„æˆçš„ï¼Œç„¶åç»„åˆæŒ‰è¡Œå·é‡æ„åçš„å­—ç¬¦ä¸²å³å¯ã€‚

```C
char* convert(char* s, int numRows) {
    int len = strlen(s);
    if (!s || numRows <= 1 || len < numRows) return s; // no need to convert

    char* zigzag = malloc(sizeof(char) * (len + 1));
    int cur = 0;

    for (int i = 0; i < numRows; i++) {
        for (int j = i; j < len; j += 2 * (numRows - 1)) { // æ¯ä¸ª v å­—å‹é•¿åº¦
            zigzag[cur++] = s[j];
            if (i != 0 && i != numRows - 1) { // ä¸­é—´è¡Œæœ‰æ–œçº¿
                int t = j + 2 * (numRows - 1) - 2 * i; // V çš„ç¬¬äºŒç¬”
                if (t < len)
                    zigzag[cur++] = s[t];
            }
        }
    }
    zigzag[cur] = '\0';
    return zigzag;
}
```

7 ç¿»è½¬æ•°å­—, æº¢å‡ºè¿”å›0
------

æ³¨æ„æº¢å‡º

```C
int reverse(int x) {
    if (x == INT_MIN) return 0;
    if (x < 0) return -reverse(-x);

    long result = 0;
    while (x) {
        result = result * 10 + x % 10;
        x /= 10;
    }

    return result > INT_MAX ? 0 : result;
}
```

8 å®ç° atoi
------

è¿™é“é¢˜è€ƒå¯Ÿå„ç§ç»†èŠ‚ï¼Œæ³¨æ„å„ç§ç‰¹æ®Šæƒ…å†µï¼š

1. é¦–å…ˆè¿‡æ»¤ç©ºæ ¼
2. åˆ¤å®šç¬¦å·, ç¬¦å·åªèƒ½å‡ºç°ä¸€æ¬¡
3. æ˜¯å¦æº¢å‡º, æº¢å‡ºè¿”å› `INT_MAX` æˆ–è€… `INT_MIN`

```C
int myAtoi(char* str) {
    if (!str) return 0;
    int sign = 1;
    int result = 0;

    // discarding spaces
    while (isspace(*str))
        str++;

    // determining sign
    if (*str == '-' || *str == '+') {
        if (*str == '-') sign = -1;
        if (*str == '+') sign = 1;
        str++;
    }

    // constructing integer
    while (isdigit(*str)) {
        // handling overflow
        if (result > INT_MAX / 10 || result == INT_MAX / 10 && *str - '0' > INT_MAX % 10)
            return sign > 0 ? INT_MAX : INT_MIN;
        result = *str - '0' + result * 10;
        str++;
    }

    return result * sign;
}
```

9 æ˜¯å¦æ˜¯å›æ–‡æ•°å­—
------

é™å®šä¸èƒ½ç”¨é¢å¤–ç©ºé—´, æ‰€ä»¥ç›´æ¥æŠŠ x å–ä½™å¾—åˆ°çš„æ•°å­—ä½œä¸ºä¸€ä¸ªåå‘ä½œä¸ºä¸€ä¸ªæ–°çš„æ•°å­—

```C
bool isPalindrome(int x) {

    // tricky here, for x == k * 10^j
    if (x < 0 || x && (x % 10 == 0)) return false;
    int y = 0;
    while (x > y) {
        y = y * 10 + x % 10;
        x /= 10;
    }

    return x == y || x == y / 10; // æ³¨æ„ x å¯èƒ½æ˜¯å¥‡æ•°é•¿åº¦ä¹Ÿå¯èƒ½æ˜¯å¶æ•°
}
```

10 æ­£åˆ™è¡¨è¾¾å¼
------

å®ç°æ­£åˆ™è¡¨è¾¾å¼, åªéœ€è¦å®ç°`.`ä»£è¡¨ä»»æ„å­—ç¬¦, `*`ä»£è¡¨ä»»æ„é‡å¤ã€‚åªéœ€è¦ç‰¹æ®Šå¤„ç†`*`ï¼Œ
å¦‚æœé‡åˆ°äº†`*`ï¼Œè´ªå©ªåœ°å‘ååŒ¹é…ã€‚å’Œé€šé…ç¬¦çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œæ­£åˆ™è¡¨è¾¾å¼éœ€è¦ä¸¤ä¸ªå­—æ¯
ç»„æˆæ¨¡å¼ï¼Œ`*`æ˜¯å¯¹å‰ä¸€ä¸ªå­—æ¯çš„ä¿®é¥°ã€‚

```C
bool isMatch(char* s, char* p) {
    for (char c = *p; c != 0; s++, c = *p) {
        // if next char in pattern is not *
        if (*(p+1) != '*')
            p++;
        // if we got an *, check if we can skip `.*` or `x*`
        else if (isMatch(s, p + 2))
            return true;

        // s ends or p and s differs
        if (*s == 0 || c != '.' && c != *s)
            return false;
    }
    return *s == 0;
}
```

11 Container with most water
------

ä»å·¦å³å‘ä¸­é—´é€¼è¿‘ï¼Œå¦‚æœæœ‰æ›´å¤§çš„å°±æ›´æ–°

```C++
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int result = 0;
    while (left < right) {
        water = min(height[left], height[right]) * (right - left)
        result = max(result, water);
        if (height[left] < height[right])
            left++;
        else
            right--;
    }
    return result;
}
```


12 åè¿›åˆ¶è½¬æ¢ä¸ºç½—é©¬æ•°å­—
------

ç›´æ¥æŒ‰æ¯ä½æŠŠç½—é©¬æ•°å­—è½¬æ¢å‡ºæ¥åœ¨æ‹¼æ¥å°±å¥½äº†, ä½¿ç”¨ C çš„è¯, æ‹¼æ¥å­—ç¬¦ä¸²å¾ˆéº»çƒ¦ã€‚

```C++
string intToRoman(int num) {
    // note, the leading empty string is the trick here
    string thousands[] = {"", "M", "MM", "MMM"};
    string handreds[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    string tens[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    string ones[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    return thousands[num / 1000] + handreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];
}
```

```C
char *intToRoman(int num) {
    int digits[4] = {0};
    char* romans = (char*)malloc(sizeof(char));
    char* cursor = romans;
    // if num = 1234, then
    // digits = {1, 2, 3, 4};
    int base = 1000;
    for (int i = 0; i < 4; i++) {
        digits[i] = num / base;
        num = num % base;
        base /= 10;
    }
    doRoman(digits[0], '_', '_', 'M', &cursor); // '_' can be anything
    doRoman(digits[1], 'M', 'D', 'C', &cursor);
    doRoman(digits[2], 'C', 'L', 'X', &cursor);
    doRoman(digits[3], 'X', 'V', 'I', &cursor);
    *cursor = '\0';
    return romans;
}

void doRoman(int number, char ten, char five, char one, char** str) {

    switch (number) {
        case 9:
            (*str)[0] = one;
            (*str)[1] = ten;
            (*str) += 2;
            break;
        case 8:
            (*str)[0] = five;
            (*str)[1] = one;
            (*str)[2] = one;
            (*str)[3] = one;
            (*str) += 4;
            break;
        case 7:
            (*str)[0] = five;
            (*str)[1] = one;
            (*str)[2] = one;
            (*str) += 3;
            break;
        case 6:
            (*str)[0] = five;
            (*str)[1] = one;
            (*str) += 2;
            break;
        case 5:
            (*str)[0] = five;
            (*str) += 1;
            break;
        case 4:
            (*str)[0] = one;
            (*str)[1] = five;
            (*str) += 2;
            break;
        case 3:
            (*str)[0] = one;
            (*str)[1] = one;
            (*str)[2] = one;
            (*str) += 3;
            break;
        case 2:
            (*str)[0] = one;
            (*str)[1] = one;
            (*str) += 2;
            break;
        case 1:
            (*str)[0] = one;
            (*str) += 1;
            break;
        case 0:
        default:
            break;
    }
}
```

13 ç½—é©¬æ•°å­—è½¬ä¸ºåè¿›åˆ¶
------

ä¸»è¦æ˜¯å½“å‰ä¸€ä¸ªæ•°å­—å°äºåä¸€ä¸ªæ•°å­—çš„æ—¶å€™, éœ€è¦æ·»åŠ çš„æ˜¯åä¸€ä¸ªæ•°å’Œå‰ä¸€ä¸ªæ•°å­—çš„å·®


```C
// acts like a dict or map
int getVal(char c) {
    switch (c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
    }
}

int romanToInt(char* s) {
    int result = 0;
    for (int i = 0; s[i] != 0; ) {
        if (getVal(s[i]) < getVal(s[i+1]))
            result += getVal(s[i+1]) - getVal(s[i]), i += 2;
        else
            result += getVal(s[i]), i++;
    }
    return result;
}
```

14 æœ€é•¿å…¬å…±å‰ç¼€
------

ä¸€ç§ naive çš„åšæ³•ï¼š

çºµå‘æ‰«æ, ä»å¤´åˆ°å°¾, å¦‚æœä¸ä¸€è‡´, è¿”å›å½“å‰å­ä¸²å³å¯ã€‚

å¦‚æœçº¦å®šä¸èƒ½æ›´æ”¹å½“å‰å­—ç¬¦ä¸², æœ€å¥½ç”¨C++åš, ä¸ç„¶æ“ä½œå­—ç¬¦ä¸²å¤ªå¤æ‚äº†, æ²¡å¿…è¦å‡ºé”™ã€‚

å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ trie

```C++
// å¾…ç»­
```

```C
// çºµå‘æ‰«æ
char* longestCommonPrefix(char** strs, int strsSize) {
    if (!strs || !strs[0]) return "";
    if (strsSize == 1) return strs[0];
    int len = strlen(strs[0]);

    for (int i = 0; i < len; i++) {
        for (int j = 1; j < strsSize; j++) {
            if (strs[j][i] != strs[0][i]) {
                strs[0][i] = '\0';
                return strs[0];
            }
        }
    }
    return strs[0];
}
```

15 ä»æ•°ç»„ä¸­æ‰¾å‡ºä¸‰ä¸ªæ•°ä½¿å¾—ä»–ä»¬çš„å’Œæ˜¯0
------

ä½¿ç”¨ C åš, è¿”å›å€¼å¤ªå¤æ‚äº†, æ‰€ä»¥ç”¨ C++ åšäº†ã€‚

é¦–å…ˆæŠŠæ•°ç»„æ’åº, ç„¶åä½¿ç”¨ç±»ä¼¼ two sum çš„æ–¹æ³•åšå°±å¥½äº†

```C++
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    for (int i = 0; i < nums.size(); i++) {
        if (i > 0 && nums[i] == nums[i-1])
            continue;
        int k = nums.size() - 1;
        int j = i + 1;
        while (j < k) {
            if (nums[i] + nums[j] + nums[k] > 0)
                k--;
            else if (nums[i] + nums[j] + nums[k] < 0)
                j++;
            else {
                result.push_back({nums[i], nums[j], nums[k]});
                // skipping duplicates
                while (j < k && nums[k] == nums[k - 1])
                    k--;
                while (j < k && nums[j] == nums[j + 1])
                    j++;
                k--; // åˆ«å¿˜äº†è¿™é‡Œï¼Œè¿˜è¦ç»§ç»­å¯»æ‰¾ä¸‹ä¸€ç»„
                j++;
            }
        }
    }
    return result;
}
```

16 åœ¨æ•°ç»„ä¸­æ‰¾åˆ°ä¸‰ä¸ªæ•°å­—ä½¿å¾—ä»–ä»¬å¾—å’Œå°½å¯èƒ½çš„æ¥è¿‘ç»™å®šæ•°å­—, å‡è®¾ç»“æœå”¯ä¸€
------

å’Œä¸Šä¸€é¢˜è§£æ³•ç±»ä¼¼, åœ¨ http://stackoverflow.com/q/2070359 æœ‰è¯¦å°½è§£é‡Š

```C
int cmp(int* a, int* b) {
    return *a - *b;
}

int threeSumClosest(int* nums, int numsSize, int target) {
    if (numsSize <= 3)
        return nums[0] + nums[1] + nums[2];
    qsort(nums, numsSize, sizeof(int), cmp);

    int result = nums[0] + nums[1] +nums[2];
    for (int i = 0; i < numsSize; i++) {
        int j = i + 1;
        int k = numsSize - 1;
        while (j < k) {
            int sum = nums[i] + nums[j] + nums[k];
            if (sum == target)
                return target;
            if (abs(target - sum) < abs(target - result))
                result = sum;
            if (sum > target)
                k--;
            else
                j++;
        }
    }
    return result;
}
```

17 ç”Ÿæˆç”µè¯é”®ç›˜æŒ‰é”®æ•°å­—å¯¹åº”çš„æ‰€æœ‰å¯èƒ½çš„å­—ç¬¦ä¸², ä¸é™åˆ¶è¿”å›ç»“æœçš„é¡ºåº
------

![é”®ç›˜](http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

éå†æ•°å­—, è®¾å½“å‰ç»“æœä¸º`{a, b, c}`, ä¸‹ä¸€ä¸ªæ•°å­—æ˜¯`3`, æ‰¾å‡ºå¯¹åº”çš„å­—æ¯`{d, e, f}`, åˆ™æ–°çš„ç»“æœæ˜¯

```
{ a + {def}, b + {def}, c + {def}}
```

ç„¶åæŠŠæ–°è·å¾—çš„æ•°ç»„ä½œä¸ºä¸‹ä¸€è½®çš„åˆå§‹æ•°ç»„ã€‚æœ€å¼€å§‹æ—¶, ä½¿ç”¨ç©ºæ•°ç»„å¼€å§‹ã€‚

```C++
// iterative
vector<string> letterCombinations(string digits) {
    if (digits.size() == 0) return vector<string> {};
    string mapping[] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> combinations(1, ""); // æ³¨æ„ä½¿ç”¨ç©ºå­—ç¬¦ä¸²ä½œä¸ºç§å­

    for (int i = 0; i < digits.size(); i++) {
        int digit = digits[i] - '0';
        if (mapping[digit].empty())
            continue;
        vector<string> temp;
        for (auto& c : mapping[digit])
            for (auto& combination : combinations)
                temp.push_back(combination + c);
        swap(combinations, temp);
    }
    return combinations;
}
```

è¿˜å¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆçš„æœç´¢æ–¹æ³•

```C++
// recursive
```

è¿½é—®ï¼šå¦‚ä½•é€šè¿‡ç”¨æˆ·æŒ‰çš„æ•°å­—æ¥æŸ¥æ‰¾æ˜¯å¦æœ‰å¯¹åº”çš„å•è¯å‘¢

1. é€šè¿‡æŠŠæ‰€æœ‰çš„å•è¯è®¡ç®—å‡ºæ¥ï¼Œç„¶åæŸ¥è¯¢å“ªä¸ªæ˜¯åˆæ³•çš„ï¼ŒæŸ¥è¯¢å¯ä»¥ä½¿ç”¨Trie
2. é€šè¿‡æŠŠå·²ç»æœ‰çš„å•è¯å­—å…¸è½¬æ¢ä¸ºæ•°å­—å­—å…¸ï¼Œç„¶åé€šè¿‡æ•°å­—åºåˆ—æŸ¥è¯¢å¯èƒ½çš„å•è¯ç»„åˆã€‚

18 4Sum
------

```C++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> result;
    int n = nums.size();

    if (n < 4) return result;

    sort(nums.begin(), nums.end());
    unordered_map<int, vector<pair<int, int>>> hash;
    for(int i = 0; i < n; i++){
        for(int j = i + 1; j < n; j++){
            hash[nums[i]+nums[j]].push_back(make_pair(i,j));
        }
    }

    for (int i = 0; i < n; i++) {
        if (i > 0 && nums[i] == nums[i-1])
            continue;
        for (int j = i+1; j < n; j++) {
            if (j > i + 1 && nums[j] == nums[j-1])
                continue;
            int re = target - nums[i] - nums[j];
            if (hash.find(re) != hash.end()) {
                for (auto match : hash[re]) {
                    int k = match.first, l = match.second;
                    if (k > j) {
                        if (!result.empty()
                            && result.back()[0] == nums[i] && result.back()[1] == nums[j]
                            && result.back()[2] == nums[k] && result.back()[3] == nums[l])
                        continue;
                        result.push_back({nums[i], nums[j], nums[k], nums[l]});
                    }
                }
            }
        }
    }
    return result;
}
```

19 åˆ é™¤é“¾è¡¨ä¸­å€’æ•°ç¬¬ k çš„èŠ‚ç‚¹
------

åŒæŒ‡é’ˆç»å…¸é¢˜ç›®, ä¸€ä¸ªå¿«æŒ‡é’ˆå…ˆèµ° k æ­¥, å¦ä¸€ä¸ªæ…¢æŒ‡é’ˆå†å‡ºå‘, æ³¨æ„é“¾è¡¨é•¿åº¦å°äº k æ—¶ã€‚

æ³¨æ„ï¼šLeetCode ç»™å®šçš„ n éƒ½æ˜¯æœ‰æ•ˆåœ°, ä½†è¦æ±‚è¿”å›å¤´æŒ‡é’ˆ, å¦‚æœå¤´æŒ‡é’ˆè¢«åˆ é™¤éœ€è¦é¢å¤–æ³¨æ„, å› æ­¤é‡‡ç”¨ dummy head

```C
struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
    struct ListNode dummy, *fast, *slow;
    dummy.next = fast = head;
    slow = &dummy;

    while (n--)
        fast = fast->next;
    while (fast) {
        fast = fast->next;
        slow = slow->next;
    }
    struct ListNode* next = slow->next;
    slow->next = next->next;
    free(next); // remeber to free memory
    return dummy.next;
}
```


20 åˆ¤å®šç»™å®šçš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯åˆæ³•çš„æ‹¬å·åºåˆ—, å¯èƒ½åŒ…æ‹¬å¤§ä¸­å°ä¸‰ç±»
------

ä½¿ç”¨æ ˆçš„åŸºç¡€é¢˜ï¼Œæ³¨æ„é€»è¾‘ç®€åŒ–

```C
char opposite(char c) {
    switch (c) {
        case ')' : return '(';
        case ']' : return '[';
        case '}' : return '{';
    }
}

bool isValid(string s) {
    stack<char> stk;
    for (auto& c : s) {
        if (c == '(' || c == '[' || c == '{')
            stk.push(c);
        else if (!stk.empty() && stk.top() == opposite(c))
            stk.pop();
        else
            return false;
    }

    return stk.empty(); // æ³¨æ„ä¸ºç©ºçš„æ¡ä»¶
}
```

21 åˆå¹¶ä¸¤ä¸ªå·²ç»æ’åºçš„é“¾è¡¨
------

è€ƒå¯Ÿé“¾è¡¨çš„åŸºæœ¬æ“ä½œ, å¾ˆç®€å•

```C
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    if (l1 == NULL) return l2;
    if (l2 == NULL) return l1;
    struct ListNode dummy;
    dummy.next == NULL;
    struct ListNode* p = &dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            p->next = l1;
            l1 = l1->next;
        } else {
            p->next = l2;
            l2 = l2->next;
        }

        p = p->next;
    }

    if (l1)
        p->next = l1;

    if (l2)
        p->next = l2;

    return dummy.next;
}
```

22 ç»™å®šæ•°å­—n, ç”Ÿæˆæ‰€æœ‰åˆæ³•çš„ n ä¸ªæ‹¬å·ç»„æˆçš„åºåˆ—
------

Cracking ä¸Šè¿˜æä¾›äº†å¦ä¸€ç§å¤æ‚çš„æ€è·¯

```C++
vector<string> generateParenthesis(int n) {
    vector<string> result;
    gen(result, "", n, n);
    return result;
}

// left å‰©ä¸‹çš„å·¦æ‹¬å·ï¼Œright å‰©ä¸‹çš„å³æ‹¬å·
void gen(vector<string>& result, string s, int left, int right) {
    if (left == 0 && right == 0) {
        result.push_back(s);
        return;
    }
    if (left != 0)
        gen(result, s + '(', left - 1, right);
    if (left < right)
        gen(result, s + ')', left, right - 1);
}
```

23 åˆå¹¶ k ä¸ªå·²ç»æ’åºçš„åˆ—è¡¨
------

æŠŠåˆ—è¡¨çœ‹åšä¸€ä¸ªé˜Ÿåˆ—, æ¯æ¬¡æ‹¿å‡ºä¸¤ä¸ªåˆ—è¡¨, åˆå¹¶ä»–ä»¬åæ”¾å›åˆ°åˆ—è¡¨ä¸­, æ¯æ¬¡éå†åˆ—è¡¨çš„ä¸€åŠ, è¿™æ ·æ¯æ¬¡éå†å®Œä¸€é,
åˆ—è¡¨çš„é•¿åº¦éƒ½ä¼šå‡åŠ, ç›´åˆ°åˆ—è¡¨çš„é•¿åº¦ä¸º1,  åˆå¹¶å‡½æ•°ä½¿ç”¨21é¢˜ä¸­çš„åˆå¹¶ä¸¤ä¸ªåˆ—è¡¨çš„å‡½æ•°

```C
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    // see above
}

struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {
    if (!lists || listsSize < 1)
        return NULL;

    while (listsSize > 1) {
        // listsize is halfed
        for (int i = 0; i < listsSize / 2; i++)
            // merge i and last i list
            lists[i] = mergeTwoLists(lists[i], lists[listsSize-1-i]);
        listsSize = (listsSize + 1) / 2; // æ³¨æ„è¿™é‡Œï¼

    }
    return lists[0];
}
```

24 ç»™å®šä¸€ä¸ªé“¾è¡¨, äº¤æ¢ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹çš„å€¼
------

æœ€ç®€å•çš„åšæ³•æ˜¾ç„¶æ˜¯ç›´æ¥æŠŠå‰åä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼äº¤æ¢, ä½†æ˜¯LeetCodeè§„å®šä¸èƒ½æ”¹å˜èŠ‚ç‚¹çš„å€¼ã€‚
ä¸»è¦è€ƒå¯Ÿé“¾è¡¨çš„æŒ‡é’ˆæ“ä½œ, æ³¨æ„å„ç§ç»†èŠ‚, ä¸€å®šè¦åœ¨çº¸ä¸Šå…ˆæŠŠé“¾è¡¨ç”»å‡ºæ¥ã€‚

```C
struct ListNode* swapPairs(struct ListNode* head) {
    struct ListNode dummy, *temp, *pnext, *p = &dummy;
    dummy.next = head;
    while (p->next && p->next->next) {
        temp = p->next;
        p->next = temp->next;
        temp->next = p->next->next;
        p->next->next = temp;
        p = temp;
    }
    return dummy.next;
}
```

25 ç»™å®šä¸€ä¸ªé“¾è¡¨, æŠŠç›¸é‚»çš„ k ä¸ªèŠ‚ç‚¹åè½¬
------

å’Œä¸Šé¢˜ä¸€æ ·, åŒæ ·ç¦æ­¢æ”¹å˜èŠ‚ç‚¹çš„å€¼ã€‚æ¯”è¾ƒç®€å•åœ°è§£æ³•æ˜¯æµªè´¹ä¸€ç‚¹ç©ºé—´, ä½¿ç”¨ Stack, å®ç°é€†è½¬ k ä¸ªèŠ‚ç‚¹, æ³¨æ„å¦‚æœ k è¾ƒå¤§çš„è¯, è¿™ç§æ–¹æ³•æ˜¯ä¸åˆé€‚çš„ã€‚

```C++
ListNode* reverseKGroup(ListNode* head, int k) {
    stack<ListNode*> stk;
    ListNode dummy(-1), *p = &dummy, *pp;
    dummy.next = head;
    while (1) {
        pp = p;
        for (int i = 0; i < k; i++) {
            if (pp->next) {
                stk.push(pp->next);
                pp = pp->next;
            } else {
                break;
            }
        }

        if (stk.size() < k) // å‰©ä¸‹çš„èŠ‚ç‚¹ä¸å¤Ÿ k ä¸ªäº†
            return dummy.next;

        pp = stk.top()->next; // ä¸‹ä¸€ç»„ä¸­çš„ç¬¬ä¸€ä¸ª
        while (!stk.empty()) {
            p->next = stk.top();
            stk.pop();
            p = p->next;
        }

        p->next = pp;
    }
}
```

26 ä»å·²æ’åºæ•°ç»„ä¸­åˆ é™¤é‡å¤å…ƒç´ , å¹¶è¿”å›æ–°æ•°ç»„çš„é•¿åº¦
------

in-placeçš„åˆ é™¤é‡å¤å…ƒç´ , ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ, ä¸€ä¸ªéå†, ä¸€ä¸ªæŒ‡å‘å½“å‰çš„ç»“å°¾ã€‚

PSï¼šè¿™ä¸ªåŸºç¡€é¢˜ç«Ÿç„¶åšäº†åŠä¸ªå°æ—¶æ‰åšå¯¹, âŠ™ï¹âŠ™bæ±—, è¦åŠ å¼ºåŸºç¡€å•Šï¼

```C
int removeDuplicates(int* nums, int numsSize) {
    if (numsSize <= 1) return numsSize;
    int len = 0;
    for (int i = 0; i < numsSize; i++)
        if (i == 0 || nums[i] != nums[len - 1])
            nums[len++] = nums[i];
    return len;
}
```

27 åˆ é™¤å…ƒç´ 
------

å’Œä¸Šä¸€é¢˜ç±»ä¼¼, æ³¨æ„ç»†èŠ‚

```C
int removeElement(int* nums, int numsSize, int val) {
    if (!nums || numsSize == 0) return 0;
    int len = 0;
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] != val)
            nums[len++] = nums[i];
    }
    return len;
}
```

28 å®ç° strstr å‡½æ•°, å³æŸ¥æ‰¾å­ä¸²
------

ä½¿ç”¨æš´åŠ›ç®—æ³•, æ—¶é—´å¤æ‚åº¦O(n)ã€‚ä¹Ÿå¯ä»¥ç”¨ kmp ç®—æ³•ã€‚

```C
/*
 * Brute Force
 */
int strStr(char* haystack, char* needle) {
    int h = strlen(haystack);
    int n = strlen(needle);
    if (n == 0) return 0;
    // note h - n + 1
    for (int i = 0; i < h - n + 1; i++) {
        for (int j = 0; j < n; j++) {
            if (needle[j] != haystack[i+j])
                break;
            if (j == n - 1)
                return i;
        }
    }
    return -1;
}
```

```C
/*
 * KMP
 */

int strStr(char* haystack, char* needle) {
    if (strlen(needle) == 0) return 0;
    return kmp(needle, haystack);
}

void construct(char* pattern, int* lps) {

    int n = strlen(pattern);
    lps[0] = 0;
    int i = 1, len = 0;
    while (i < n) {
        if (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } else {
            if (len != 0)
                len = lps[len - 1];
            else
                lps[i++] = 0;
        }
    }
}

int kmp(char* needle, char* haystack) {

    int n = strlen(needle);
    int m = strlen(haystack);

    int* lps = malloc(sizeof(int) * n);
    construct(needle, lps);

    int i = 0, j = 0;
    while (i < m) {
        if (haystack[i] == needle[j])
            i++, j++;
        if (j == n) {
            return i - n;
            j = lps[j - 1];
        } else if (i < m && needle[j] != haystack[i]) {
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }

    free(lps);
    return -1;
}
```

29 ç»™å®šè¿ä¸ªæ•´æ•°, ä¸ä½¿ç”¨ä¹˜æ³•å’Œé™¤æ³•è®¡ç®—é™¤æ³•ã€‚
------

[è¿™é‡Œ](https://leetcode.com/discuss/38997/detailed-explained-8ms-c-solution)æœ‰ä¸€ä¸ªéå¸¸å¥½çš„ç®—æ³•

è®¡ç®—å¯ä»¥ä»è¢«é™¤æ•°ä¸­å‡å»é™¤æ•°çš„æ¬¡æ•°

```C
int divide(int dividend, int divisor) {
    // abs(INT_MIN) == INT_MAX + 1
    if (divisor == 0 || (dividend == INT_MIN && divisor == -1))
        return INT_MAX;
    int sign = (dividend > 0) == (divisor > 0) ? 1 : -1;
    long long n = labs(dividend);
    long long d = labs(divisor);

    int result = 0;
    while (n >= d) {
        long long temp = d;
        long long multi = 1;
        while (n >= (temp << 1)) {
            temp <<= 1;
            multi <<= 1;
        }
        n -= temp;
        result += multi;
    }

    return sign * result;
}
```

30 åŒ…å«æ‰€æœ‰å•è¯çš„å­å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæ‰€æœ‰ã€‚å•è¯çš„é•¿åº¦éƒ½æ˜¯ä¸€æ ·çš„
------

```C++
vector<int> findSubstring(string s, vector<string>& words) {
    unordered_map<string, int> counts;
    for (string word : words)
        counts[word]++;
    int n = s.length(), num = words.size(), len = words[0].size();
    vector<int> indexes;
    for (int i = 0; i < n - num * len + 1; i++) {
        unordered_map<string, int> seen;
        int j = 0;
        for (; j < num; j++) {
            string word = s.substr(i + j * len, len);
            if (counts.find(word) != counts.end()) {
                seen[word]++;
                if (seen[word] > counts[word])
                    break;
            } else {
               break;
            }
        }
        if (j == num)
            indexes.push_back(i);
    }
    return indexes;
}
```

31 å…¨æ’åˆ—ï¼Œä¸‹ä¸€ä¸ª
------

é¦–å…ˆ, å¯¹äºæ‰€æœ‰çš„ç»„åˆ, æœ€å°çš„ä¸€ä¸ªä¸€å®šæ˜¯æŒ‰ç…§å‡åºæ’åºçš„, æœ€å¤§çš„ä¸€å®šæ˜¯å€’è¿‡æ¥, å› æ­¤

1. å¦‚æœæˆ‘ä»¬å‘ç°æ˜¯å€’åºçš„, ç›´æ¥ç¿»è½¬å°±å¥½äº†ï¼›
2. å¦‚æœæ˜¯ä¸€èˆ¬æƒ…å†µ, ä»åå‘å‰éå†, æ‰¾åˆ°é€†åºçš„æ•°å­—çš„è¾¹ç•Œ,  å‡è®¾æ˜¯ kã€‚é‚£ä¹ˆæˆ‘ä»¬ç¿»è½¬

```C++
void nextPermutation(vector<int>& nums) {
    int k = -1; // å‡åºæ’åˆ—çš„æœ€åä¸€ä¸ªæ•°å­—
    for (int i = nums.size() - 2; i >= 0; i--) {
        if (nums[i] < nums[i + 1]) {
            k = i;
            break;
        }
    }
    // å®Œå…¨æ˜¯é€†åºçš„ï¼Œç›´æ¥è¿”å›ç¬¬ä¸€ä¸ªï¼Œä¹Ÿå°±æ˜¯å‡åºæ’åˆ—
    if (k == -1) {
        reverse(nums.begin(), nums.end());
        return;
    }
    int l = -1; // é€†åºæ•°å­—ä¸­æ¯” k å¤§çš„æœ€å°çš„æ•°å­—
    for (int i = nums.size() - 1; i > k; i--) {
        if (nums[i] > nums[k]) {
            l = i;
            break;
        }
    }
    swap(nums[k], nums[l]); // ä¿è¯å˜å¤§
    reverse(nums.begin() + k + 1, nums.end()); // ä¿è¯æ˜¯ä¸‹ä¸€ä¸ª
}
```

32 ä»ä¸€ä¸ªæ‹¬å·æ„æˆçš„å­—ç¬¦ä¸²ä¸­æ‰¾å‡ºæœ€é•¿çš„åˆæ³•æ‹¬å·åºåˆ—
------

æ˜¾ç„¶åˆ¤å®šåˆæ³•æ‹¬å·é¡ºåºçš„é¢˜éƒ½å¯ä»¥ç”¨æ ˆæ¥åš, ä½†æ˜¯ä¸å¦¨ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥å°è¯•ä¸€ä¸‹ ğŸ˜„

åŠ¨æ€è§„åˆ’: è§æ³¨é‡Š

```C
int longestValidParentheses(char* s) {
    int len = strlen(s);
    // éå†åˆ°å½“å‰ä½ç½®æ—¶çš„æœ€é•¿åºåˆ—
    int dp[len];
    for (int i = 0; i < len; i++)
        dp[i] = 0;
    int longest = 0;
    // ä»å€’æ•°ç¬¬äºŒä¸ªä½ç½®å¼€å§‹éå†
    for (int i = len - 2; i >= 0; i--) {
        // å°è¯•æŠŠä¸Šä¸€ä¸ªåºåˆ—åŒ…å›´ä½
        int match = i + dp[i+1] + 1; // å‘å³æŸ¥æ‰¾é…å¯¹æ‹¬å·
        if (s[i] == '(' && match < len && s[match] == ')') {
            dp[i] = dp[i+1] + 2;
            // æ‹¼æ¥åˆæ³•åºåˆ—ï¼Œæ³¨æ„ match + 1 è¡¨ç¤º match å³ä¾§ç›¸é‚»çš„åˆæ³•åºåˆ—
            if (match + 1 < len)
                dp[i] += dp[match + 1];
        }
        longest = longest > dp[i] ? longest : dp[i];
    }
    return longest;
}
```

33 åœ¨æ’åºååˆè¢«åè½¬çš„æ•°ç»„ä¸­æœç´¢
------

æ—¢ç„¶æ˜¯éƒ¨åˆ†æœ‰åºçš„,è‡ªç„¶è¿˜æ˜¯ä½¿ç”¨äºŒåˆ†æœç´¢äº†,æ³¨æ„ç»ˆæ­¢æ¡ä»¶.
ä¸åŒäºæ™®é€šäºŒåˆ†æœç´¢çš„ä¸¤ç§æƒ…å†µ, æˆ‘ä»¬æœ‰äº†å››ç§æƒ…å†µ:

1. å‰åŠéƒ¨åˆ†æœ‰åº, å¹¶ä¸”åœ¨å‰åŠéƒ¨åˆ†å½“ä¸­,
2. å‰åŠéƒ¨åˆ†æœ‰åº, ä½†æ˜¯ä¸åœ¨å‰åŠéƒ¨åˆ†
3. ååŠéƒ¨åˆ†æœ‰åº, å¹¶ä¸”åœ¨ååŠéƒ¨åˆ†
4. ååŠéƒ¨åˆ†æœ‰åº, ä½†æ˜¯ä¸åœ¨ååŠéƒ¨åˆ†

```C
int search(int* nums, int numsSize, int target) {
    int left = 0, right = numsSize - 1;

    // plain old binary search
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target)
            return mid;

        // left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        // right half is sorted
        } else {
            if (nums[mid] < target && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }

    return -1;
}
```

34 æŸ¥æ‰¾æ•°ç»„ä¸­ä¸€ä¸ªé‡å¤å‡ºç°æ•°å­—çš„ä¸‹ç•Œå’Œä¸Šç•Œ, æ•°ç»„å·²æ’åº
------

åœ¨ C++çš„æ ‡å‡†åº“ä¸­åŒ…å«äº†è¿™ä¸¤ä¸ªå‡½æ•°, åˆ†åˆ«æ˜¯`std::lower_bound`å’Œ`std::upper_bound`.


```C++
vector<int> searchRange(vector<int>& nums, int target) {
    return vector<int> {lower(nums, target), upper(nums, target)};
}

int lower(vector<int>& nums, int target) {
    int first = 0, last = nums.size();
    while (first < last) {
        int middle = first + (last - first) / 2;
        if (target > nums[middle]) // å¯»æ‰¾ä¸‹ç•Œ
            first = middle + 1;
        else
            last = middle;
    }
    return nums[first] == target ? first : -1;
}

int upper(vector<int>& nums, int target) {
    int first = 0, last = nums.size();
    while (first < last) {
        int middle = first + (last - first) / 2;
        if (target >= nums[middle]) // å¯»æ‰¾ä¸Šç•Œonly difference with lower
            first = middle + 1;
        else
            last = middle;
    }

    // note: std::upper_bound return offset by 1
    return nums[first - 1] == target ? first - 1 : -1;
}
```

35 äºŒåˆ†æŸ¥æ‰¾æ•°å­—, å¦‚æœæ²¡æœ‰æ‰¾åˆ°, è¿”å›åº”è¯¥æ’å…¥çš„ä½ç½®
------

å°±æ˜¯æœ€åŸºç¡€çš„äºŒåˆ†æŸ¥æ‰¾


```C
int searchInsert(int* nums, int numsSize, int target) {
    int left = 0, right = numsSize - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return left;
}
```

36 åˆæ³•æ•°ç‹¬, ç»™å®šä¸€ä¸ªæ•°ç‹¬è¡¨,åˆ¤å®šå½“å‰æ˜¯å¦åˆæ³•
------

```C
// æœ‰ç‚¹æµªè´¹ç©ºé—´
bool isValidSudoku(char** board, int row, int col) {
    bool used_row[9][9] = {false}, used_col[9][9] = {false}, used_box[9][9] = {false};
    for (int i = 0; i < row; i++)
        for (int j = 0; j < col; j++)
            if (board[i][j] != '.') {
                int num = board[i][j] - '0' - 1;
                int k = i / 3 * 3 + j / 3;
                if (used_row[i][num] || used_col[j][num] || used_box[k][num])
                    return false;
                used_row[i][num] = used_col[j][num] = used_box[k][num] = true;
            }
    return true;
}
```

37 æ±‚è§£æ•°ç‹¬
------

```C++
void solveSudoku(vector<vector<char>>& board) {
    solve(board, 0);
}
bool solve(vector<vector<char>>& board, int ind){
    if(ind==81) return true;
    int i=ind/9, j=ind%9;
    if(board[i][j]!='.')
        return solve(board, ind+1);
    else{
        for(char f = '1'; f <= '9'; f++) {
            if(isValidFill(board, i, j, f)) {
                board[i][j]= f;
                if(solve(board, ind+1)) return true;
                board[i][j]='.';
            }
        }
        return false;
    }
}
bool isValidFill(vector<vector<char>>& board, int i, int j, char fill) {
    for(int k=0; k<9; k++) {
        if(board[i][k]==fill) return false; //check the row
        if(board[k][j]==fill) return false; //check the column
        int r= i/3*3+j/3;   //select the block
        if(board[r/3*3+k/3][r%3*3+k%3]==fill) return false; //check the block
    }
    return true;
}
```

38 æ•°æ•°å¹¶è¯´å‡ºæ¥
------

ä¸å¤ªç†è§£è¿™é“é¢˜æœ‰ä»€ä¹ˆæ„ä¹‰,ç›´æ¥æš´åŠ›åšå‡ºæ¥äº†

```C++
string countAndSay(int n) {
    string result = "1";
    for (int i = 0; i < n -1; i++) {
        string temp;
        for (int j = 0; j < result.size(); j++) {
            int count = 1;
            while (j + 1 < result.size() && result[j+1] == result[j]) {
                j++; count++;
            }
            temp += count + '0';
            temp += result[j];
        }
        result = temp;
    }
    return result;
}
```

39 ç»™å®šä¸€ä¸ªé›†åˆï¼Œåœ¨é›†åˆä¸­æ‰¾å‡ºå’Œä¸ºtargetçš„æ•°å­—ï¼Œæ•°å­—å¯ä»¥ä½¿ç”¨å¤šæ¬¡ï¼Œé›†åˆä¸­æ²¡æœ‰é‡å¤æ•°å­—
------

å…¸å‹çš„æ·±åº¦ä¼˜å…ˆæœç´¢

```C++
vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> result;
    dfs(result, candidates, {}, target);
    return result;
}

void dfs(vector<vector<int>>& result, vector<int>& candidates, vector<int> comb, int target) {
    if (target == 0) {
        result.push_back(comb);
        return;
    }

    for (auto c : candidates) {
        if (c > target) continue; // æ•°å­—å¤ªå¤§äº†
        if (!comb.empty() && c < comb.back()) continue; // ä¿è¯ä¸é‡å¤ä¸”å‡åº
        comb.push_back(c);
        dfs(result, candidates, comb, target - c);
        comb.pop_back(); // æ³¨æ„æ­¤å¤„è¿˜éœ€è¦å¼¹å‡ºï¼Œå› ä¸ºéœ€è¦å¾ªç¯
    }
}
```

40 åŒä¸Šé¢˜ä¸€æ ·ï¼Œä½†æ˜¯é›†åˆä¸­çš„æ•°å­—åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œå¹¶ä¸”é›†åˆä¸­æœ‰é‡å¤æ•°å­—
------

```C++
vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    vector<vector<int>> result;
    sort(candidates.begin(), candidates.end());
    dfs(result, candidates, {}, target, 0);
    return result;
}

void dfs(vector<vector<int>>& result, vector<int>& candidates, vector<int> comb, int target, int start) {
    if (target == 0) {
        result.push_back(comb);
        return;
    }

    for (int i = start; i < candidates.size(); i++) {
        if (candidates[i] > target)
            break;
        if (i != start && candidates[i] == candidates[i-1])
            continue;
        comb.push_back(candidates[i]);
        dfs(result, candidates, comb, target - candidates[i], i + 1);
        comb.pop_back();
    }
}
```

41 ç»™å®šä¸€ä¸ªæ•°ç»„,æ‰¾åˆ°ç¬¬ä¸€ä¸ªç¼ºå¤±çš„æ­£æ•°
------

æ˜¾ç„¶,ç»“æœçš„èŒƒå›´æ˜¯[1..n+1]. è€Œæ•°ç»„çš„é•¿åº¦ä¸º n æˆ‘ä»¬æŠŠæ¯ä¸ªä½ç½®éƒ½æ”¾ä¸Š i+1,
è¿™æ ·å¦‚æœæœ‰ä½ç½®ä¸æ˜¯ i+1, åˆ™æ‰¾åˆ°äº†ç»“æœ, å¦‚æœéƒ½ç›¸ç­‰åˆ™æ˜¯ n+1.

```c
void swap(int* a, int* b) {
    int t = *a; *a = *b; *b = t;
}

int firstMissingPositive(int* nums, int numsSize) {
    for (int i = 0; i < numsSize; i++)
        // æ³¨æ„æ­¤å¤„çš„ while
        while (nums[i] > 0 && nums[i] <= numsSize && nums[i] != nums[nums[i] - 1])
            swap(&nums[i], &nums[nums[i] - 1]);

    for (int i = 0; i < numsSize; i++)
        if (nums[i] != i + 1)
            return i + 1;

    return numsSize + 1;
}
```

42 ç»™å®šä¸€ä¸ªæ•°ç»„è¡¨ç¤ºæŸ±å­çš„é«˜åº¦ï¼Œæ±‚èƒ½å­˜è´®çš„é›¨æ°´çš„æ€»é‡
------

ä»ä¸¤è¾¹å‘ä¸­é—´æ”¶æ‹¢

```C
int trap(int* height, int heightSize) {
    int left = 0, right = heightSize - 1;
    int water = 0;
    int max_left = 0, max_right = 0;

    // ä»ä¸¤ä¾§å‘ä¸­é—´ç¼©å°, å¯ä»¥ç®—ä½œæ˜¯ä¸¤ä¸ªæŒ‡é’ˆå§
    while (left <= right) {
        if (height[left] <= height[right]) {
            if (height[left] >= max_left)
                max_left = height[left];
            else
                water += max_left - height[left];
            left++;
        } else {
            if (height[right] >= max_right)
                max_right = height[right];
            else
                water += max_right - height[right];
            right--;
        }
    }
    return water;
}
```

43 ç»™å®šä¸¤ä¸ªä»»æ„é•¿çš„å­—ç¬¦ä¸²ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä»£è¡¨ä»–ä»¬ç›¸ä¹˜çš„ç»“æœ
------

æŒ‰æ•´æ•°é™¤æ³•è¿ç®—å³å¯ï¼Œé‡ç‚¹æ˜¯ä¸‹æ ‡çš„è¡¨ç¤º

```C
#define tonum(c) (c - '0')
#define tochar(i) (i + '0')

char* multiply(char* num1, char* num2) {
    // ç»“æœçš„é•¿åº¦ä¸ä¼šè¶…è¿‡ m+n,
    // å‡è®¾æŸä¸ªæ•°æ˜¯ n ä½çš„9, åˆ™ç»“æœæ¯”å¦ä¸€ä¸ªæ•°ç»“å°¾åŠ ä¸Š n ä¸ª 0è¿˜å°
    int n = strlen(num1), m = strlen(num2);
    int len = m+n;
    char* result = malloc(sizeof(char) * (len + 1));
    for (int i = 0; i < len; i++)
        result[i] = '0';
    result[len] = '\0';

    for (int i = n - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = m - 1; j >= 0; j--) {
            int v = tonum(result[i+j+1]) +  tonum(num1[i]) * tonum(num2[j]) + carry;
            result[i+j+1] = tochar(v % 10);
            carry = v / 10;
        }
        result[i] += carry;
    }

    for (int i = 0; i < len; i++)
        if (result[i] != '0')
            return result+i;

    return "0";
}
```

44 é€šé…ç¬¦åŒ¹é…ï¼Œ`?` ä»£è¡¨ä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œ`*`ä»£è¡¨ä»»æ„ä¸€ä¸ªæˆ–å¤šä¸ªå­—ç¬¦
------

æ³¨æ„å’Œæ­£åˆ™è¡¨è¾¾å¼çš„åŒºåˆ«ï¼Œè¦æ±‚å®Œå…¨åŒ¹é…ã€‚è¿™é“é¢˜çš„å…³é”®åœ¨äºå¯¹æ˜Ÿå·çš„å¤„ç†, å¦‚æœå‡ºç°æ˜Ÿå·çš„æ—¶å€™, æˆ‘ä»¬è®°å½•å½“æ—¶çš„p å’Œ s çš„å€¼, å¦‚æœå‘ç”Ÿäº†ä¸åŒ¹é…çš„è¯, æˆ‘ä»¬å°è¯•å›åˆ°è¯¥ä½ç½®çš„ä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹åŒ¹é…

```C

bool isMatch(char* s, char* p) {
    char* star = NULL;
    char* revert = s;
    while (*s) {
        if (*s == *p || *p == '?')
            s++, p++;
        else if (*p == '*')
            star = p++, revert = s;
        else if (star)
            p = star + 1, s = ++revert;
        else
            return false;
    }

    // å¦‚æœå‰©ä¸‹äº† p, é‚£åº”è¯¥å…¨éƒ½æ˜¯*æ‰å¯¹
    while (*p) {
        if (*p++ != '*')
            return false;
    }

    return true;
}
```

45 è·³è·ƒæ¸¸æˆï¼Œç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªæ•°å­—æ˜¯åœ¨è¯¥ä½ç½®å¯ä»¥å‘å‰ç§»åŠ¨çš„è·ç¦»ï¼Œè¿”å›æœ€å°‘éœ€è¦å¤šå°‘æ¬¡æ‰èƒ½åˆ°è¾¾ç»ˆç‚¹
------

æ¯”è¾ƒç®€å•ï¼Œçœ‹æ³¨é‡Šå§

```C
int jump(int* nums, int numsSize) {
    int steps = 0;
    int last = 0; // last range
    int cur = 0; // current range

    for (int i = 0; i < numsSize; i++) {
        // beyond range, make another jump
        if (i > last)
            last = cur, steps++;
        // if we could reach longer?
        if (nums[i] + i > cur)
            cur = nums[i] + i;
    }
    return steps;
}
```

46 ç”Ÿæˆå…¨æ’åˆ—
------

Crackingä¸Šç»™å‡ºäº†ä¸€ç§è§£æ³•ï¼Œé€šè¿‡ä¸æ–­çš„æ·»åŠ ä¸‹ä¸€ä¸ªå…ƒç´ åˆ°ä¸Šä¸€ç»„å…ƒç´ çš„ä¸åŒä½ç½®æ¥ç”Ÿæˆå…¨æ’åˆ—ï¼Œè¿™æ ·å›ºç„¶å¯ä»¥ï¼Œä½†æ˜¯å¤§è§„æ¨¡çš„æ‹¼æ¥æ•°ç»„æˆ–è€…å­—ç¬¦ä¸²æ˜¯å¾ˆè€—è´¹èµ„æºçš„ã€‚

åœ¨å·²ç»æœ‰äº†å­—ç¬¦ä¸²ï¼ˆæˆ–è€…æ•°ç»„ï¼‰çš„åˆå§‹æ’åˆ—ä»¥åï¼Œå¯ä»¥é€šè¿‡ä¸æ–­äº¤æ¢çš„æ–¹æ³•ç”Ÿæˆæ¯ä¸€ç»„å…¨æ’åˆ—ã€‚
æ¯”å¦‚å¯¹äºxyzï¼Œæˆ‘ä»¬æœ‰å…¨æ’åˆ—ä¸º

    x + per(yx)
    y + per(xz)
    z + per(xy)

é‚£ä¹ˆæˆ‘ä»¬é€šè¿‡æŠŠæ¯ä¸ªå…ƒç´ äº¤æ¢åˆ°ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå°±æŠŠé—®é¢˜è§„æ¨¡ç¼©å°äº†ï¼ŒçŸ¥é“æŠŠé—®é¢˜è§„æ¨¡ç¼©å°ä¸º1.

```C++
vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> result;
    per(result, nums, 0);
    return result;
}

void per(vector<vector<int>>& result, vector<int>& nums, int begin) {
    if (begin >= nums.size()) {
        result.push_back(nums);
        return;
    }

    for (int i = begin; i < nums.size(); i++) { // æ³¨æ„æ˜¯ä»beginå¼€å§‹ï¼Œè¿™æ ·æœªæ”¹å˜çš„æ‰èƒ½åŠ å…¥è¿›æ¥
        swap(nums[begin], nums[i]);
        per(result, nums, begin + 1);
        swap(nums[begin], nums[i]); // æ³¨æ„å› ä¸ºå‚æ•°ä¸­æ˜¯ä¼ å¼•ç”¨ï¼Œè¿™é‡Œéœ€è¦å¤åŸ
    }
}
```

```Rust
impl Solution {
    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = vec![];
        Self::per(&mut result, nums, 0);
        result
    }

    pub fn per(result: &mut Vec<Vec<i32>>, nums: Vec<i32>, begin: usize) {
        if begin >= nums.len() {
            result.push(nums);
            return
        }
        for i in begin..nums.len() {
            let mut nums = nums.clone();
            nums.swap(begin, i);
            Self::per(result, nums, begin + 1);
        }
    }
}
```

47 å…¨æ’åˆ—ï¼Œæ•°ç»„ä¸­æœ‰é‡å¤å…ƒç´ 
------

å’Œä¸Šä¸€é¢˜åŸºæœ¬æ˜¯ä¸€æ ·çš„ï¼Œæ³¨æ„è·³è¿‡é‡å¤å…ƒç´ å°±å¥½äº†

```C++
vector<vector<int>> permuteUnique(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    per(result, nums, 0);
    return result;
}

void per(vector<vector<int>>& result, vector<int> nums, int start) {
    if (start >= nums.size()) {
        result.push_back(nums);
        return;
    }

    for (int i = start; i < nums.size(); i++) {
        if (start != i && nums[start] == nums[i])
            continue;
        swap(nums[start], nums[i]);
        per(result, nums, start + 1); // äº‹å®è¯æ˜ï¼Œä¼ å¼•ç”¨åå€’ä¼šè¶…æ—¶
    }
}
```

48 ç»™å®šä¸€ä¸ª`n*n`çš„å›¾åƒæ—‹è½¬å›¾åƒï¼Œé¡ºæ—¶é’ˆæ—‹è½¬90åº¦
------

åšæ³•æ˜¾ç„¶æ˜¯ä»é‡Œåˆ°å¤–ï¼Œä¸€å±‚ä¸€å±‚çš„æ—‹è½¬ï¼Œè¿™é“é¢˜ä¸»è¦è€ƒå¯Ÿä¸‹æ ‡çš„æ“ä½œ

```C
void rotate(int** matrix, int m, int n) {
    for (int layer = 0; layer < n / 2; layer++) {
        int first  = layer;
        int last = n - 1 - layer;
        for (int i = first; i < last; i++) {
            int offset = i - first;
            int top = matrix[first][i];
            // up <- left
            matrix[first][i] = matrix[last-offset][first];
            // left <- down
            matrix[last-offset][first] = matrix[last][last-offset];
            // down <- right
            matrix[last][last-offset] = matrix[i][last];
            // right <- up
            matrix[i][last] = top;
        }
    }
}
```

49 ç»™å®šå­—ç¬¦æ•°ç»„ï¼ŒæŠŠä»–ä»¬æŒ‰ç…§Anagramåˆ†ç»„
------

```C++
// Anagram åˆ†ç»„
// è¿™é“é¢˜æ²¡ä»€ä¹ˆå¯åšçš„ï¼Œåªéœ€è¦ç»Ÿè®¡
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    vector<vector<string>> result;
    string temp;
    unordered_map<string, vector<string>> records;
    for (int i = 0; i < strs.size(); ++i) {
        temp = strs[i];
        sort(temp.begin(), temp.end());
        records[temp].push_back(strs[i]);
    }
    for (auto& record : records) {
        sort(record.second.begin(), record.second.end());
        result.push_back(record.second);
    }
    return result;
}
```

50 å®ç°pow(x, n)
------

æ˜¾ç„¶ä¸èƒ½ç›´æ¥é˜¶ä¹˜è¿‡å»ï¼Œåˆ†æ²»æ³•

é€’å½’åšæ³•
```C
// recursive
double myPow(double x, int n) {
    if (n == INT_MIN) return myPow(x, n - 1) * x;
    if (n < 0) return 1 / myPow(x, -n);
    if (n == 0) return 1;
    if (n == 1) return x;
    double y = myPow(x, n / 2);
    if (n & 0x1)
        return y * y * x;
    else
        return y * y;
}
```

è¿­ä»£åšæ³•
```C
// iteratively
double myPow(double x, long p) {
    double result = 1;
    if (p < 0)
         return 1 / myPow(x, -p);
    while (p) {
        if (p & 1)
            result *= x;
        x *= x;
        p /= 2;
    }
    return result;
}
```

51 N çš‡åé—®é¢˜
------

éœ€è¦å¤§å¹…åº¦ä¿®æ”¹

```C++
// Nçš‡åé—®é¢˜ï¼Œçš‡åä¸èƒ½å†ä¸€æ¡ç›´çº¿ï¼Œä¸€æ¡ç«–çº¿ï¼Œä¸€æ¡æ–œçº¿ä¸Š

// ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæ±‚è§£ï¼Œå¯¹äº dfs é—®é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆæŠŠç®—æ³•çš„æ¡†æ¶å†™ä¸‹æ¥ï¼Œç„¶åç¡®å®šè¿™ä¸ªé—®é¢˜çš„é™åˆ¶æ¡ä»¶
// å¯¹äºè¿™ä¸ªé—®é¢˜ï¼Œé™åˆ¶æ¡ä»¶å½“å‰è¡Œçš„å…ƒç´ ä¸èƒ½åœ¨ä»¥å‰çš„åˆ—ä¸­å‡ºç°è¿‡ï¼Œä¹Ÿä¸èƒ½åœ¨å¯¹è§’çº¿ä¸­å‡ºç°è¿‡
vector<vector<string>> result;

vector<vector<string>> solveNQueens(int n) {
    if (n < 1) return result;
    vector<int> x(n);
    dfs(0, x, n);
    return result;

}

void dfs(int t, vector<int>& x, int n) {
    // å½“æ–°æ·»åŠ ä¸€ä¸ª Q åˆ°å½“å‰è§£çš„æ—¶å€™
    if (t >= n) {
        // result.push_back(make_solution(x));
        // return;
        vector<string> solution;
        for (int i = 0; i < n; i++) {
            string line(n, '.');
            line[x[i]] = 'Q';
            solution.push_back(line);
        }
        result.push_back(solution);
    } else {
        for (int i = 0; i < n; i++) {
            bool skip = false;
            for (int j = 0; j < t; j++) {
                if (x[j] == i || abs(i - x[j]) == abs(t - j)) {
                    skip = true;
                    break;
                }
            }
            if (skip) continue;
            x[t] = i;
            dfs(t+1, x, n);
        }
    }
}
```

52 N çš‡åä¸€å…±æœ‰å¤šå°‘ä¸ªè§£
------

ä¸è¦ç›´æ¥æŠŠçš‡åæ”¾å¥½ï¼Œè€Œæ˜¯æŠŠå ç”¨çš„éƒ½è®°å½•ä¸‹æ¥ï¼Œç„¶åç»§ç»­æ·±åº¦ä¼˜å…ˆæœç´¢

```C++
class Solution {
public:
    unordered_set<int> cols, digs1, digs2;
    int totalNQueens(int n) {
        return total(0, 0, n);
    }

    int total(int row, int count, int n) {
        for (int col = 0; col < n; col++) {
            if (cols.find(col) != cols.end()
                || digs1.find(row - col) != digs1.end()
                || digs2.find(row + col) != digs2.end())
            continue;

            if (row == n-1)
                count++;
            else {
                cols.insert(col);
                digs1.insert(row-col);
                digs2.insert(row+col);
                count = total(row+1, count, n);
                cols.erase(col);
                digs1.erase(row-col);
                digs2.erase(row+col);
            }
        }
        return count;
    }
};
```

53 æœ€å¤§å­åºåˆ—å’Œ
------

åŠ¨æ€è§„åˆ’ç»å…¸é¢˜ç›®ï¼Œéå†æ•°ç»„ï¼Œå¦‚æœå·²ç»å½“å‰å­åºåˆ—å·²ç»å°äº0äº†ï¼ŒæŠ›å¼ƒå¹¶ç½® sum = 0
å¦‚æœæ¯”å½“å‰å’Œæ›´å¤§ï¼Œæ›´æ–°ã€‚å¯¹äºä¸€ä¸ªå­åºåˆ—ï¼Œè¦ä¹ˆä½¿å¾—åºåˆ—å’Œå¢å¤§ï¼Œè¦ä¹ˆå‡å°ã€‚

`dp[n+1] = max(dp[n], dp[n] + A[n+1])`

```C
int maxSubArray(int* nums, int numsSize) {
    int sum = 0;
    int m = INT_MIN;

    for (int i =0; i< numsSize; i++) {
        sum += nums[i];
        if (sum > m)
            m = sum;
        if (sum < 0)
            sum = 0;
    }
    return m;
}
```

54 é¡ºæ—¶é’ˆèºæ—‹æ‰“å°çŸ©é˜µ
------

ä¸€åœˆä¸€åœˆåœ°æ‰“å°å°±å¥½äº†

```C
int* spiralOrder(int** matrix, int row, int col) {
    if (row == 0 || col == 0) return NULL;
    int top = 0, right = col - 1, down = row - 1, left = 0;
    int index = 0;
    int* result = malloc(sizeof(int) * row * col);
    while (top <= down && left <= right) {
        for (int i = left; i <= right; i++)
            result[index++] = matrix[top][i];
        top++; //
        for (int i = top; i <= down; i++)
            result[index++] = matrix[i][right];
        right--; //
        // æ³¨æ„è¿™ä¸ª if è¯­å¥
        if (top <= down)
            for (int i = right; i >= left; i--)
                result[index++] = matrix[down][i];
        down--; //
        // æ³¨æ„è¿™ä¸ª if è¯­å¥
        if (left <= right)
            for (int i = down; i >= top; i--)
                result[index++] = matrix[i][left];
        left++; //
    }
    return result;
}
```

55 ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªæ•°å­—è¡¨ç¤ºåœ¨å½“å‰æ­¥å¯ä»¥ç§»åŠ¨çš„è·ç¦»ï¼Œè¿”å›æ˜¯ä¸æ˜¯èƒ½å¤Ÿåˆ°è¾¾ç»ˆç‚¹
------

ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ï¼Œå¦‚æœå½“å‰è·ç¦»å¤§äºæœ€è¿œè·ç¦»ï¼Œæ›´æ–°æœ€è¿œè·ç¦»ï¼Œå¦‚æœå·²ç»è¶…è¿‡äº†æœ€è¿œè·ç¦»ï¼Œè·³å‡º

```C
bool canJump(int* nums, int numsSize) {
    int i;
    int reach = 0;
    for (i = 0; i < numsSize && i <= reach; i++)
            reach = max(reach, nums[i] + i);
    return i == numsSize;
}
```

56 åˆå¹¶åºåˆ—ï¼Œç»™å®šä¸€ç»„åºåˆ—ï¼ŒæŠŠå…¶ä¸­é‡å çš„åºåˆ—åˆå¹¶
------

è¿™é“é¢˜ç”¨ Python åšç«Ÿç„¶æ¯”ç”¨ C++ è¿˜è¦å¿«

```Python
"""
class Interval(object):
    def __init__(self, start=0, end=0):
        self.start = start
        self.end= end
"""

def merge(intervals):
    intervals.sort(key=lambda x: x.start)
    combined = []
    for interval in intervals:
        if combined and interval.start <= combined[-1].end:
            combined[-1].end = max(combined[-1].end, interval.end)
        else:
            combined.append(interval)
    return combined
```

57 æ·»åŠ åºåˆ—ï¼Œç»™å®šä¸€ç»„å·²ç»æ’åºçš„åºåˆ—ï¼Œå‘å…¶ä¸­æ’å…¥ä¸€ä¸ªåºåˆ—ï¼Œéœ€è¦åˆå¹¶çš„åˆå¹¶
------

è¿™é“é¢˜inplace çš„åšæ³•æ„Ÿè§‰æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œå› ä¸ºå¦‚æœåœ¨ä¸­é—´æ’å…¥çš„è¯ï¼ŒååŠéƒ¨åˆ†è¿˜æ˜¯è¦è¢«æ‹·è´

```Python
def insert(self, intervals, newInterval):
    result = []
    start = newInterval.start
    end = newInterval.end
    remainder = 0
    for interval in intervals:
        if start <= interval.end:
            if end < interval.start:
                break
            start = min(start, interval.start)
            end = max(end, interval.end)
        else:
            result.append(interval)
        remainder += 1
    result.append(Interval(start, end))
    result += intervals[remainder:]
    return result
```

58 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å…¶ä¸­æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦
------

æ˜¾ç„¶è¿™é“é¢˜å¯ä»¥ç”¨ strlen æ±‚å‡ºé•¿åº¦ç„¶åä»åå¾€å‰æ•°ï¼Œä½†æ˜¯ï¼Œè¿™æ ·ç›¸å½“äºå¤šéå†äº†ä¸€æ¬¡
ç›´æ¥ä»åå¾€å‰å¯ä»¥ä¿è¯åªéå†ä¸€æ¬¡

```C
int lengthOfLastWord(char* s) {
    int len = 0;
    bool inWord = false;
    while (*s) {
        if (isspace(*s)) {
            inWord = false;
        } else {
            if (!inWord) {
                len = 1;
                inWord = true;
            } else {
                len++;
            }
        }
        s++;
    }
    return len;
}
```

59 ç»™å®š nï¼ŒæŠŠ1, 2, 3 ...èºæ—‹æ‰“å°åˆ°çŸ©é˜µä¸­
------

å’Œä¸Šä¸€ä¸ªå®Œå…¨ä¸€æ ·çš„æ€è·¯ï¼Œåªæ˜¯è¿™æ¬¡æ˜¯æ‰“å°ç½¢äº†

```C
/**
 * Return an array of arrays.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n) {
    int** matrix = malloc(sizeof(int*) * n);
    for (int i = 0; i < n; i++)
        matrix[i] = malloc(sizeof(int) * n);

    int top = 0, left = 0, down = n - 1, right = n - 1;
    int a = 1;
    while (top <= down && left <= right) {
        for (int i = left; i <=right; i++)
            matrix[top][i] = a++;
        top++;
        for (int i = top; i <= down; i++) {
            matrix[i][right] = a++;
        }
        right--;
        if (top <= down)
            for (int i = right; i >= left; i--)
                matrix[down][i] = a++;
        down--;
        if (left <= right)
            for (int i = down; i >= top; i--)
                matrix[i][left] = a++;
        left++;
    }
    return matrix;
}
```

60 ç»™å®šnä¸ªæ•°å­—ï¼Œæ‰¾å‡ºç¬¬kä¸ªPermutation
------

```C++
class Solution {
public:
    /*The logic is as follows:
    for n numbers the permutations can be divided to (n-1)! groups,
    thus k/(n-1)! indicates the index of current number,
    and k%(n-1)! denotes remaining sequence (to the right).
    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.
    */
    string getPermutation(int n, int k) {
        int f = 1;
        string s(n, '0');
        for (int i = 1; i <= n; i++) {
            f *= i;
            s[i-1] = i + '0';
        }
        // ç»™å®šn,ä¸€å…±æœ‰n!ä¸ªåºåˆ—ï¼Œf == n!

        k--;
        for (int i = 0; i < n; i++) {
            f /= n - i; // f /= n, f /= n - 1 ...
            int j = i + k / f;
            char c= s[j];
            for (;j > i; j--) // shift space to put `c`, actually we could use swap
                s[j] = s[j-1];
            s[i] = c;
            k %= f;
        }

        return s;
    }
};
```

61 æŠŠåˆ—è¡¨æ—‹è½¬åˆ°å€’æ•°ç¬¬ k ä½
------

éœ€è¦æ³¨æ„çš„æ˜¯ k å¤§äºåˆ—è¡¨é•¿åº¦çš„æƒ…å†µï¼Œè¿™æ—¶å€™éœ€è¦å–ä½™

```C
struct ListNode* rotateRight(struct ListNode* head, int k) {
    if (!head || k <= 0) return head;

    int l = 1;
    struct ListNode* n = head;
    while (n->next) {
        n = n->next;
        l++;
    }
    // n is now the tail!

    if (k >= l) k %= l;
    if (k == 0) return head;

    struct ListNode dummy, *p = &dummy;
    dummy.next = head;
    int i = l - k;
    while (i--)
        p = p->next;

    dummy.next = p->next;
    p->next = NULL;
    n->next = head;

    return dummy.next;
}
```

62 ç»™å®šä¸€ä¸ª`m*n`çš„çŸ©é˜µï¼Œæœ‰å¤šå°‘ç§æ–¹æ³•ä»å·¦ä¸Šè§’ç§»åŠ¨åˆ°å³ä¸‹è§’
------

æ˜¾ç„¶å¯ä»¥ä½¿ç”¨ç»„åˆæ•°å­¦ç›´æ¥æ±‚å‡ºæ¥è§£ï¼Œä½†æ˜¯å®¹æ˜“æº¢å‡ºã€‚è€Œä¸”è¿™æ˜¯ä¸€é“ç»å…¸çš„åŠ¨æ€è§„åˆ’é¢˜ç›®ï¼Œå¯¹äº
æ¯ä¸ªæ ¼å­ï¼Œå¯ä»¥ä»ä»–çš„ä¸Šéƒ¨æˆ–è€…å·¦é¢ç§»åŠ¨è¿‡æ¥ã€‚

```C++
int uniquePaths(int m, int n) {
    vector<vector<int>> grid(m, vector<int> (n, 1));
    for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
    return grid[m - 1][n - 1];
}
```

63 åŒä¸Šé¢˜ï¼ŒåŒºåˆ«æ˜¯åœ¨ä¸€äº›ä½ç½®æ˜¯æœ‰éšœç¢ç‰©çš„
------

ç»è¿‡åˆ†æå¯çŸ¥ï¼Œé€’æ¨å…³ç³»æ˜¯ä¸€æ ·çš„ï¼Œåªéœ€è¦æŠŠæœ‰éšœç¢æ ¼å­çš„åˆ°è¾¾æ–¹æ³•è®¾å®šä¸º0ã€‚è¿™ä¸ªä¸»è¦æ˜¯å®ç°ä¸Šçš„ä¸€äº›æŠ€å·§ï¼Œ
è§æ³¨é‡Šã€‚

```C++
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m = obstacleGrid.size(), n = obstacleGrid[0].size();
    // æ³¨æ„è®¾å®šé•¿å®½å‡ +1ï¼Œä½†æ˜¯åˆå§‹åŒ–ä¸º0ï¼Œè¾¹ç•Œå°±æˆäº†éšœç¢
    vector<vector<int>> pathes(m + 1, vector<int> (n + 1, 0));
    pathes[0][1] = 1; // ç»™å®šä¸€ä¸ªå…¥å£
    for (int i = 1; i < m + 1; i++)
        for (int j = 1; j < n + 1; j++)
            // æ³¨æ„æ­¤å¤„çš„åç§»
            if (obstacleGrid[i-1][j-1] == 1)
                pathes[i][j] = 0;
            else
                pathes[i][j] = pathes[i-1][j] + pathes[i][j-1];
    return pathes[m][n];
}
```

64 ç»™å®šä¸€ä¸ª`m*n`çŸ©é˜µï¼Œæ¯ä¸ªæ•°å­—ä»£è¡¨ç»è¿‡è¯¥å¤„çš„è€—è´¹ï¼Œæ‰¾å‡ºä¸€æ¡è€—è´¹æœ€å°çš„è·¯å¾„
------

ä¾ç„¶æ˜¯åŠ¨æ€è§„åˆ’

```C++
int minPathSum(vector<vector<int>>& grid) {
    // if modifying the grid is disallowed, copy it
    int m = grid.size(), n = grid[0].size();
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (i == 0 && j == 0)
                continue;
            else if (i == 0 && j != 0)
                grid[i][j] += grid[i][j-1];
            else if (i != 0 && j == 0)
                grid[i][j] += grid[i-1][j];
            else
                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);
    return grid[m-1][n-1];
}
```

65 åˆ¤å®šä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯åˆæ³•çš„æ•°å­—ï¼ŒåŒ…æ‹¬äº†æ­£è´Ÿå·ï¼Œå°æ•°ç‚¹ï¼Œ`e`ç­‰
------

ä¸€äº›ä¾‹å­ï¼š

    "0" => true
    " 0.1 " => true
    "abc" => false
    "1 a" => false
    "2e10" => true

è¿™é“é¢˜å°±æ˜¯ç»†èŠ‚é¢˜ï¼Œç”¨ C å¤„ç†å­—ç¬¦ä¸²å¤ªè›‹ç–¼äº†ï¼Œç›´æ¥ä¸Š Python äº†

```Python
def isNumber(self, s):
    BEFORE = 0 # before dot
    AFTER = 1 # after dot
    EXP = 2 # after e
    phase = BEFORE
    allow_sign = True

    s = s.strip()

    if not any([c.isdigit() for c in s]):
        return False

    if s == '' or s[0] == 'e' or s[-1] == 'e' or s == '.':
        return False
    if s[0] == '.' and s[1] == 'e':
        return False
    if s[0] == '-' and s[1] == 'e':
        return False

    for c in s:
        if '0' <= c <= '9':
            allow_sign = False
        elif c == '.':
            allow_sign = False
            if phase == EXP or phase == AFTER:
                return False
            else:
                phase = AFTER
        elif c == 'e':
            if phase == EXP:
                return False
            allow_sign = True
            phase = EXP

        elif c == '-' or c == '+':
            if not allow_sign:
                return False
            allow_sign = False
        else:
            return False

    if phase == EXP:
        return s[-1].isdigit()

    return True
```

66 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ä»£è¡¨çš„æ•°å­—ï¼Œè¿”å›åŠ 1åçš„æ•°å­—
------

æˆ‘ä»¬çŸ¥é“åªæœ‰å½“æ•°å­—æ˜¯999....999çš„æ—¶å€™ï¼Œæ‰ä¼šä½¿å¾—æ•°å­—çš„é•¿åº¦+1å˜ä¸º1000...000ã€‚

æˆ‘ä»¬çŸ¥é“åªæœ‰å½“æ•°å­—æ˜¯999...999çš„æ—¶å€™ï¼Œæ‰ä¼šä½¿å¾—æ•°å­—çš„é•¿åº¦+1å˜ä¸º1000..000ã€‚

```C++
vector<int> plusOne(vector<int>& digits) {
    int n = digits.size();
    for (int i = n - 1; i >= 0; i--) {
        if (digits[i] == 9) {
            digits[i] = 0;
        } else {
            digits[i]++;
            return digits;
    // real trick here, we know that the number is 999...999
    }
    // real trick here, we know that the number is 999..999
    // æ”¹æˆinsert
    digits[0] = 1;
    digits.push_back(0);
    return digits;
}
```

67 ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²ä»£è¡¨çš„äºŒè¿›åˆ¶æ•°å­—ï¼Œè¿”å›ä»–ä»¬ç›¸åŠ çš„å’Œ
------

å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼ŒæŒ‰ç…§åŠ æ³•å®šä¹‰åšå°±å¥½äº†

```C
#define tonum(c) (c - '0')
#define tochar(i) (i + '0')

char* addBinary(char* a, char* b) {
    int m = strlen(a), n = strlen(b);
    int len = (m > n ? m : n) + 1; // strlen(c)
    char* c = malloc(sizeof(char) * len + 1); // with ending null
    memset(c, '0', len+1);
    c[len] = 0;
    int carry = 0;
    for (int i = 1; i <= len; i++) {
         c[len-i] = tochar((i <= m ? tonum(a[m-i]) : 0) ^ (i <= n ? tonum(b[n-i]) : 0) ^ carry);
         carry = ((i <= m ? tonum(a[m-i]) : 0) + (i <= n ? tonum(b[n-i]) : 0) + carry) >> 1;
    }
    return c[0] == '0' ? c+1 : c;
}
```

68 æ–‡å­—å¯¹é½
------

å¾…ç ”ç©¶

```C++
vector<string> fullJustify(vector<string>& words, int L) {
    vector<string> res;
    for(int i = 0, k, l; i < words.size(); i += k) {
        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {
            l += words[i+k].size();
        }
        string tmp = words[i];
        for(int j = 0; j < k - 1; j++) {
            if(i + k >= words.size()) tmp += " ";
            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');
            tmp += words[i+j+1];
        }
        tmp += string(L - tmp.size(), ' ');
        res.push_back(tmp);
    }
    return res;
}
```

69 ç»™å®šæ•´æ•°xï¼Œæ±‚ sqrt(x)
------

æ¯”è¾ƒå‘çš„æ˜¯ LeetCode è¦æ±‚çš„æ˜¯ `y*y < x` çš„æœ€å¤§æ•´æ•°

```C
int mySqrt(int x) {
    if (x <= 1) return x;
    const double EPS = x * 0.0001;
    double y = x / 2; // initial guess
    while (fabs(y * y - x) > EPS) {
        y = (y + x / y) / 2;
    }

    long z = (long) y;
    while (z * z > x) z--;
    return z;
}
```

70 çˆ¬æ¢¯å­ï¼Œä¸€æ¬¡å¯ä»¥çˆ¬ä¸€æ­¥æˆ–è€…ä¸¤æ­¥ï¼Œæœ‰å‡ ç§æ–¹æ³•çˆ¬å®Œæ¢¯å­
------

æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºåŠ¨æ€è§„åˆ’

```C
int climbStairs(int n) {
    int a = 1, b = 1, t;
    for (int i = 1; i < n; i++)
        t = b, b += a, a = t;
    return b;
}
```

71 ç®€åŒ– Unix è·¯å¾„ï¼Œéœ€è¦å¤„ç†`.`, `..` å’Œå¤šä¸ªæ–œæ ç­‰æƒ…å†µ
------

æ²¡æœ‰ä»€ä¹ˆéœ€è¦æ³¨æ„çš„ï¼Œä¸»è¦æ˜¯ä½¿ç”¨ stringstream ç”¨ä½œstring.split

```C++
string simplifyPath(string& path) {
    vector<string> dirs;
    stringstream ss(path);
    string dir;
    while (getline(ss, dir, '/')) {
        if (dir == "." || dir == "")
            continue;
        else if (dir == "..") {
            if (!dirs.empty())
            dirs.pop_back();
        } else
            dirs.push_back(dir);
    }
    string result;
    for (auto& dir : dirs)
        if (!dir.empty())
            result += "/" + dir;
    return result.size() ? result : "/";
}
```

72 ç¼–è¾‘è·ç¦»ï¼Œå…è®¸æ›¿æ¢ï¼Œåˆ é™¤ï¼Œæ’å…¥ä¸‰ç§æ“ä½œ
------

å¯¹äºä¸¤ä¸ªå­—ç¬¦ä¸²æ¯”è¾ƒï¼Œå¾€å¾€è¦ä½¿ç”¨äºŒç»´çš„åŠ¨æ€è§„åˆ’ã€‚
ä½¿ç”¨f[i][j]è¡¨ç¤ºword1[1..i]å’Œword2[1..j]ä¹‹é—´çš„è·ç¦»ã€‚
see [here](https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space)

é‚£ä¹ˆï¼š

1. ç›¸ç­‰ f[i][j] = f[i-1][j-1];
2. ä¸ç›¸ç­‰

    1. æ›¿æ¢: f[i][j] = f[i-1][j-1] + 1;  éƒ½å‘å‰ä¸€æ­¥
    2. æ·»åŠ : f[i][j] = f[i][j-1] + 1; word2å‘å‰ä¸€æ­¥
    3. åˆ é™¤: f[i][j] = f[i-1][j] + 1; word1å‘å‰ä¸€æ­¥

å¦å¤–ä½¿ç”¨ä¸€ç»´æ•°ç»„è¡¨ç¤ºäºŒç»´æ•°ç»„è¿˜éœ€è¦äº†è§£
```C++

// unoptimized code
int minDistance(string word1, string word2) {
    int m = word1.length(), n = word2.length();
    vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));
    for (int i = 1; i <= m; i++)
        dp[i][0] = i;
    for (int j = 1; j <= n; j++)
        dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1));
        }
    }
    return dp[m][n];
}
```

```C++
// optimized
int minDistance(string word1, string word2) {
    int m = word1.length(), n = word2.length();
    vector<int> cur(m + 1, 0);
    // æŠŠå‰©ä½™çš„å­—ç¬¦åˆ æ‰çš„è·ç¦»
    for (int i = 1; i <= m; i++)
        cur[i] = i;
    for (int j = 1; j <= n; j++) {
        int pre = cur[0];
        cur[0] = j;
        for (int i = 1; i <= m; i++) {
            int temp = cur[i];
            if (word1[i - 1] == word2[j - 1])
                cur[i] = pre;
            else cur[i] = min(pre + 1, min(cur[i] + 1, cur[i - 1] + 1));
            pre = temp;
        }
    }
    return cur[m];
}
```

```C++
// recursive code from beauty of programming
// TLE on LeetCode
int minDistance(string word1, string word2) {
    return minDistance(&word1.front(), &word1.back(), &word2.front(), &word2.back())
}

int minDistance(char* start1, char* end1, char* start2, char* end2) {
    if (start1 > end1)
        return start2 > end2 ? 0 : end2 - start2 + 1;

    if (start2 > end2)
        return start1 > end1 ? 0 : end1 - start1 + 1;

    if (*start1 == *start2)
        return minDistance(start1 + 1, end1, start2 + 1, end2);
    else {
        int t1 = minDistance(start1 + 1, end1, start2 + 1, end2);
        int t2 = minDistance(start1 + 1, end1, start2, end2);
        int t3 = minDistance(start1, end1, start2 + 1, end2);
        return min(t1, min(t2, t3)) + 1;
    }
}
```

73 ç»™å®šä¸€ä¸ªçŸ©é˜µï¼Œå¦‚æœæŸä¸ªå…ƒç´ ä¸ºé›¶ï¼ŒæŠŠæ‰€åœ¨çš„è¡Œå’Œæ‰€åœ¨çš„åˆ—éƒ½è®¾ä¸ºé›¶
------

ä¸€ç§å¯ä»¥æ¥å—çš„æ–¹æ³•æ˜¯ä½¿ç”¨O(m+n)çš„ç©ºé—´ï¼Œè®°å½•å“ªè¡Œå“ªåˆ—éœ€è¦è®¾ä¸ºé›¶

```C++
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size();
    if (m == 0) return;
    int n = matrix[0].size();
    if (n == 0) return;

    vector<bool> row(m), column(n);

    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            if (matrix[i][j] == 0)
                row[i] = true, column[j] = true;

    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            if (row[i] || column[j])
                matrix[i][j] = 0;
}
```

74 æœç´¢çŸ©é˜µï¼ŒçŸ©é˜µæ¯è¡Œä»å·¦åˆ°å³ä¾æ¬¡å¢å¤§ï¼Œæ¯è¡Œéƒ½æ¯”ä¸Šä¸€è¡Œå¤§
------

å½“åšæ•°ç»„ç›´æ¥äºŒåˆ†æœç´¢å°±å¯ä»¥äº†

```C++
bool searchMatrix(int** matrix, int row, int col, int target) {
    int left = 0, right = row * col - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (matrix[mid/col][mid%col] < target)
            left = mid + 1;
        else if (matrix[mid/col][mid%col] == target)
            return true;
        else
            right = mid - 1;
    }
    return false;
}
```

75 é¢œè‰²æ’åºï¼Œæ¯ä¸ªç‰©ä½“æœ‰é¢œè‰²å±æ€§ï¼ŒæŠŠä»–ä»¬æŒ‰ç…§RGBçš„é¡ºåºæ’åº(ğŸ‡³ğŸ‡±å›½æ——é—®é¢˜)
------

ä¸€ç§æ–¹æ³•æ˜¯ç®€å•åœ°2 passè§£æ³•ï¼Œéå†ä¸€éè®¡æ•°å†è¾“å‡ºã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯æŠŠçº¢è‰²å¾€å‰äº¤æ¢ï¼Œè“è‰²å¾€åäº¤æ¢

```C
void swap(int* a, int* b) {
    int t = *a; *a = *b; *b = t;
}

void sortColors(int* nums, int numsSize) {
    const int RED = 0, GREEN = 1, BLUE = 2;
    int reds = 0,  blues = numsSize - 1;
    for (int i = 0; i <= blues; i++) {
        while (nums[i] == BLUE && i < blues) swap(&nums[i], &nums[blues--]);
        while (nums[i] == RED && i > reds) swap(&nums[i], &nums[reds++]);
    }
}
```

76 è·³è¿‡

77 ç»™å®šæ•°å­— n å’Œ kï¼Œç”Ÿæˆä» n ä¸­å–å‡º k ä¸ªæ•°å­—çš„æ‰€æœ‰æƒ…å†µ
------

æ•°å­¦ä¸Šçš„ç»„åˆï¼Œä½¿ç”¨å›æº¯æ¥åšï¼Œå¯¹çŠ¶æ€ç©ºé—´è¿›è¡Œæ·±åº¦æœç´¢ã€‚

å›æº¯æ–¹æ³•é€šå¸¸é€‚åˆå¯¹çŠ¶æ€ç©ºé—´æ ‘çš„æ·±åº¦ä¼˜å…ˆæœç´¢ç›¸ç»“åˆçš„ï¼Œå½“ä¸€ä¸ªè§£å·²ç»ä¸æ»¡è¶³æ¡ä»¶æ—¶ï¼Œå‰ªæï¼›
å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œç›´åˆ°æ‰¾åˆ°å®Œå…¨è§£æœªçŸ¥ã€‚

```C++
// ç»„åˆæ˜¯ä¸è¦æ±‚é¡ºåºçš„
vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> result;
    if (n < k)
        return result;
    vector<int> temp(0, k);
    combine(result, temp, 0, 0, n, k);
    return result;
}

void combine(vector<vector<int>>& result, vector<int>& temp, int start, int count, int n, int k) {
    // 1. å›æº¯æ¡ä»¶ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªè§£
    if (count == k) {
        result.push_back(temp);
        return;
    }
    // 2. æ·±åº¦ä¼˜å…ˆæœç´¢
    for (int i = start; i < n; i++) {
        temp.push_back(i + 1);
        // åªæœç´¢æ¯” i å¤§çš„å³å¯
        combine(result, temp, i+ 1, count+1, n, k);
        temp.pop_back();
    }
}
```

78 ç»™å®šä¸€ä¸ªé›†åˆï¼Œæ‰¾åˆ°å®ƒçš„æ‰€æœ‰å­é›†
------

è¿™é“é¢˜è‡³å°‘æœ‰3ç§è§£æ³•ï¼š

1. DFSï¼Œæˆ‘ä»¬çŸ¥é“å¯¹äº n ä¸ªå…ƒç´ çš„é›†åˆï¼Œæœ‰2^nä¸ªå­é›†ï¼Œé€šè¿‡æ¯ä¸ªå…ƒç´ åœ¨ä¸åœ¨å­é›†ä¸­æ„é€ ä¸€ä¸ªçŠ¶æ€ç©ºé—´æ ‘
2. ç±»ä¼¼äºç”µè¯é”®ç›˜ç”Ÿæˆå­—æ¯ï¼Œè¿­ä»£
3. å·§å¦™çš„åˆ©ç”¨1..2^nå¯¹åº”

```C++
// use backtracking and do a dfs search

vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    if (nums.empty()) return result;
    sort(nums.begin(), nums.end());
    vector<int> temp;
    subsets(nums, result, temp, 0);
    return result;
}

// for each solution, the can be divided into two sub solutions: in or out
void subsets(vector<int>& nums, vector<vector<int>>& result, vector<int> temp, int i) {
    if (i == nums.size()) {
        result.push_back(temp);
        return;
    }

    vector<int> t = temp;
    subsets(nums, result, temp, i + 1);
    temp.push_back(nums[i]);
    subsets(nums, result, temp, i + 1);
}
```

```C++
// iterative
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    result.push_back({});
    if (nums.empty())
        return result;
    result.push_back(vector<int>(1, nums[0]));
    for (int i = 1; i < nums.size(); i++) {
        int size = result.size(); // notice the cached size
        for (int j = 0; j < size; j++) {
            auto new_subset = result[j];
            new_subset.push_back(nums[i]);
            sort(new_subset.begin(), new_subset.end());
            result.push_back(new_subset);
        }
    }
    return result;
}
```

```C++
// tricky
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    int size = (1 << nums.size());
    for (int i = 0; i < size; i++) {
        vector<int> subset;
        int k = i;
        for (int j = 0; j < nums.size(); j++) {
            if (k & 0x1)
                subset.push_back(nums[j]);
            k >>= 1;
        }
        sort(subset.begin(), subset.end());
        result.push_back(subset);
    }
    return result;
}
```

79 ç»™å®šä¸€ä¸ªäºŒç»´å­—ç¬¦æ•°ç»„ï¼ŒæŸ¥æ‰¾ä¸€ä¸ªå•è¯æ˜¯å¦èƒ½å¤Ÿæœ‰è¿ç»­çš„å­—æ¯æ„æˆï¼Œä¸èƒ½äº¤å‰
------

ä¹Ÿæ˜¯æ·±åº¦ä¼˜å…ˆçš„åšæ³•ï¼Œé¦–å…ˆæ‰¾åˆ°å¼€å§‹çš„å­—æ¯ï¼Œç„¶åä¾æ¬¡å‘ä¸Šä¸‹å·¦å³æŸ¥æ‰¾ï¼Œæ³¨æ„è¿˜éœ€è¦ç»Ÿè®¡æœ‰æ²¡æœ‰è®¿é—®è¿‡

```C++
bool exist(vector<vector<char>>& board, string word) {
    int row = board.size();
    int col = board[0].size();
    vector<vector<bool>> visited(row, vector<bool> (col, false));

    bool found = false;
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            if (board[i][j] == word[0]) {
                if (findNext(board, word, visited, i, j, 0))
                    found = true;
            }
        }
    }
    return found;
}

bool findNext(vector<vector<char>>& board, string& word, vector<vector<bool>>& visited, int m, int n, int i) {

    if (i == word.size())
        return true;
    if (m >= board.size() || n >= board[0].size() || m < 0 || n < 0|| visited[m][n] || board[m][n] != word[i])
        return false;
    char temp = board[m][n];
    board[m][n] = -1;

    bool exist = findNext(board, word, visited, m + 1, n, i+1) ||
        findNext(board, word, visited, m - 1, n, i+1) ||
        findNext(board, word, visited, m, n+1, i+1) ||
        findNext(board, word, visited, m, n-1, i+1);
    board[m][n] = temp;
    return exist;
}
```

80 ä»æ’åºæ•°ç»„ä¸­åˆ é™¤é‡å¤å…ƒç´ ï¼Œä½†æ˜¯å…è®¸ä¸€ä¸ªå…ƒç´ é‡å¤å‡ºç°ä¸¤æ¬¡
------

å·§å¦™åœ°è§£æ³•ï¼Œå’Œ`i-2`çš„å…ƒç´ å¯¹æ¯”

```C
int removeDuplicates(int* nums, int numsSize) {
    if (!nums || numsSize < 1) return 0;
    int len = 0, counter = 0;
    for (int i = 0; i < numsSize; i++) {
        if (len < 2 || nums[i] != nums[len-2])
            nums[len++] = nums[i];
    }
    return len;
}
```

81 åœ¨è¢«ç¿»è½¬çš„æ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ ï¼Œå¯èƒ½åŒ…å«é‡å¤å…ƒç´ 
------

ç»å…¸é¢˜ç›®ï¼Œè¿˜æ˜¯ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾é—®é¢˜ï¼Œåªæ˜¯è¦åˆ†å¾ˆå¤šç§æƒ…å†µ

```C
bool search(int A[], int n, int key) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left)/2;
        if (A[mid] == key)
            return true; //return m in Search in Rotated Array I
        if (A[left] < A[mid]) { //left half is sorted
            if (A[left] <= key && key < A[mid])
                right = mid - 1;
            else
                left = mid + 1;
        } else if (A[left] > A[mid]) { //right half is sorted
            if (A[mid] < key && key <= A[right])
                left = mid + 1;
            else
                right = mid - 1;
        } else { // A[left] == A[mid]
            left++;
        }
    }
    return false;
}
```

82 ä»å·²ç»æ’åºçš„é“¾è¡¨ä¸­åˆ é™¤æ‰€æœ‰é‡å¤è¿‡çš„å…ƒç´ ï¼Œåªç•™ä¸‹åªå‡ºç°ä¸€æ¬¡çš„å…ƒç´ 
------

è€ƒå¯Ÿé“¾è¡¨æ“ä½œ

```C
struct ListNode* deleteDuplicates(struct ListNode* head) {
    struct ListNode dummy, *p = &dummy;
    dummy.next = head;
    while (p && p->next && p->next->next) {
        if (p->next->val == p->next->next->val) {
            struct ListNode* distinct = p->next;
            int dup = p->next->val;
            while (distinct && distinct->val == dup) {
                distinct = distinct->next; // TODO: fix mem leak
            }
            p->next = distinct;
        } else {
            p=p->next;
        }
    }
    return dummy.next;
}
```

83 ä»å·²ç»æ’åºçš„é“¾è¡¨ä¸­åˆ é™¤æ‰€æœ‰é‡å¤è¿‡çš„å…ƒç´ ï¼Œä½†æ˜¯é‡å¤è¿‡çš„ä¹Ÿç•™ä¸‹ä¸€ä¸ªï¼Œå³ï¼Œä½¿æ–°é“¾è¡¨ä¸é‡å¤
------

åŒæ ·æ˜¯è€ƒå¯Ÿé“¾è¡¨åŸºæœ¬æ“ä½œ

```C
struct ListNode* deleteDuplicates(struct ListNode* head) {
    struct ListNode dummy, *p = &dummy; dummy.next = head; dummy.val = head->val + 1;
    while (p && p->next) {
        if (p->val == p->next->val) {
            int dup = p->val;
            while (p->next && p->next->val == dup)
                p->next = p->next->next; // TODO: fix mem leak
        } else
            p = p->next;
    }
    return dummy.next;
}
```

84 åœ¨æŸ±çŠ¶å›¾ä¸­æŸ¥æ‰¾æœ€å¤§çš„çŸ©å½¢
------

è§æ³¨é‡Š

```C++
int largestRectangleArea(vector<int>& height) {
    stack<int> stk;
    height.push_back(0); // dummy end
    int result  =0;
    // æ€»ç»“ï¼Œå¯¹äºéœ€è¦æŸ¥æ‰¾ä¸Šä¸€æ¬¡æœ€å¤§å…ƒç´ çš„é—®é¢˜ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨æ ˆå­˜å‚¨
    for (int i = 0; i < height.size(); ) {
        // å½“é‡åˆ°æ›´é«˜çš„æŸ±å­æ—¶å€™ï¼Œå…ˆå­˜å…¥å †æ ˆ
        if (stk.empty() || height[i] > height[stk.top()]) // meet higher
            stk.push(i++);
        // å½“é‡åˆ°ä½ä¸€äº›çš„æŸ±å­æ—¶å€™ï¼Œè®¡ç®—è¿™äº›æŸ±å­åˆ°ä¸Šä¸€ä¸ªæ›´çŸ®çš„æŸ±å­ä¹‹é—´çš„æœ€å¤§ä¸¾è¡Œï¼Œå¦‚æœå·²ç»æ¸…ç©ºï¼Œè¯´æ˜ä¹‹å‰æ‰€æœ‰æŸ±å­éƒ½æ›´ä½
        else { // lower
            int h = stk.top();
            stk.pop();
            result = max(result, height[h] * (stk.empty() ? i : i - stk.top() -1));
        }
    }
    return result;
}
```

85 æœ€å¤§çš„é•¿æ–¹å½¢
------

```C
int max(int a, int b) {
    return a > b ? a : b;
}

int min(int a, int b) {
    return a < b ? a : b;
}

int maximalRectangle(char** matrix, int row, int col) {
    if (!matrix) return 0;
    int left[col], right[col], height[col];
    for (int i = 0; i < col; i++)
        left[i] = 0, right[i] = col, height[i] = 0;
    int area = 0;
    for (int i = 0; i < row; i++) {
        int cur_left = 0, cur_right = col;
        for (int j = 0; j < col; j++)
            if (matrix[i][j] == '1')  // åœ¨ç¬¬ j åˆ—çš„é«˜åº¦
                height[j]++;
            else
                height[j] = 0;
        for (int j = 0; j < col; j++)
            if (matrix[i][j] == '1')
                left[j] = max(left[j], cur_left);
            else
                left[j] = 0, cur_left = j + 1;
        for (int j = col - 1; j >= 0; j--)
            if (matrix[i][j] == '1')
                right[j] = min(right[j], cur_right);
            else
                right[j] = col, cur_right = j;
        for (int j = 0; j < col; j++)
            area = max(area, (right[j] - left[j]) * height[j]);
    }

    return area;
}
```

86 é“¾è¡¨åˆ†åŒºï¼Œè¦æ±‚æŠŠå°äºæŸä¸ªå€¼å¾—å…ƒç´ å…¨éƒ½æ”¾åˆ°å‰é¢
------

å¯¹äºé“¾è¡¨è¿™é“é¢˜å¾ˆç®€å•ï¼Œåˆ†ä¸¤ä¸ªåˆ—è¡¨åœ¨åˆå¹¶å°±å¥½äº†ï¼Œé—®é¢˜æ˜¯å½“æˆ‘ä»¬å¤„ç†ç±»ä¼¼çš„æ•°ç»„é—®é¢˜æ—¶ï¼Œä¹Ÿæœ‰ä¸€ç§å·§å¦™åœ°O(n)çš„è§£æ³•

```C
struct ListNode* partition(struct ListNode* head, int x) {
    struct ListNode small, *psmall = &small; // double dummy head
    struct ListNode big, *pbig = &big;
    psmall->next = pbig->next = NULL;

    while (head != NULL) {
        if (head->val < x) {
            psmall->next = head;
            psmall = psmall->next;
        } else {
            pbig->next = head;
            pbig = pbig->next;
        }
        head = head->next;
    }
    psmall->next = big.next;
    pbig->next = NULL;
    return small.next;
}
```

87 æŠŠå­—ç¬¦ä¸²åˆ†åŒºåï¼Œäº¤æ¢å¾—åˆ°çš„å­—ç¬¦ä¸²
------

```C++
bool isScramble(string s1, string s2) {
    if(s1==s2)
        return true;

    // å…ˆåˆ¤æ–­å­—ç¬¦æ˜¯å¦ä¸€è‡´
    int len = s1.size();
    int count[26] = {0};
    for(int i=0; i<len; i++) {
        count[s1[i]-'a']++;
        count[s2[i]-'a']--;
    }

    for(int i = 0; i < 26; i++)
        if(count[i]!=0)
            return false;

    for(int i = 1; i < len; i++) {
        if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))
            return true;
        if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))
            return true;
    }
    return false;
}
```

88 åˆå¹¶å·²æ’åºæ•°ç»„ï¼Œè¦æ±‚åˆå¹¶åˆ°å…¶ä¸­ä¸€ä¸ªç©ºé—´è¾ƒå¤§çš„æ•°ç»„ä¸­
------

å¯¹äºè¿™ç§è¦æ±‚ in-placeçš„ç®—æ³•ï¼Œä»åå¾€å‰å¾€å¾€å¯ä»¥è§£å†³

```C
void merge(int* nums1, int m, int* nums2, int n) {
    int len = m + n - 1;
    m--, n--;
    while (m >= 0 && n >= 0) {
        if (nums1[m] > nums2[n]) {
            nums1[len--] = nums1[m--];
        } else {
            nums1[len--] = nums2[n--];
        }
    }
    while (n >= 0) {
        nums1[n] = nums2[n];
        n--;
    }

}
```

89 ç”Ÿæˆæ ¼é›·ç (Gray Code)
------

è®°ä½æ ¼é›·ç çš„ç”Ÿæˆè§„åˆ™

```C++
vector<int> grayCode(int n) {
    vector<int> v;
    for (int i = 0; i < (1 << n); i++) {
        v.push_back((i >> 1) ^ i);
    }
    return v;
}
```

90 ç”±ç»™å®šå…ƒç´ ç”Ÿæˆå­é›†ï¼Œå¯èƒ½åŒ…å«é‡å¤å…ƒç´ 
------

ä½¿ç”¨äº†å’Œæ‰‹æœºé”®ç›˜ç”Ÿæˆå­—ç¬¦ä¸²å·ç ç±»ä¼¼çš„è¿­ä»£ç®—æ³•ï¼Œæ³¨æ„å…¶ä¸­å¯¹é‡å¤å…ƒç´ çš„å¤„ç†ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç”¨DFSæ¥åš

```C++
vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    vector<vector<int>> sets;
    sets.push_back({});
    sort(nums.begin(), nums.end()); // å¤„ç†åŒ…å«é‡å¤å…ƒç´ çš„ä¸€åŠéœ€è¦é¢„æ’åº
    for (int i = 0; i < nums.size(); ) {
        int count = 0; // dup count
        while (count + i < nums.size() && nums[count+i] == nums[i])
            count++;
        int prev_n = sets.size();
        for (int j = 0; j < prev_n; j++) {
            vector<int> instance = sets[j];
            // put dup element `count` times
            for (int k = 0; k < count; k++) {
                instance.push_back(nums[i]);
                sets.push_back(instance);
            }
        }
        i += count;

    }
    return sets;
}
```

91 ç»™å®šä¸€ä¸ªæ•°ç»„åªåŒ…å«1-9ï¼Œå¯ä»¥ç”¨1-26ä»£è¡¨å­—æ¯ï¼Œæ±‚å‡ºä»å…¶ä¸­èƒ½éƒ½å¾—åˆ°å¤šå°‘å­—ç¬¦ä¸²
------

ä½¿ç”¨åŠ¨æ€è§„åˆ’ï¼Œä½†æ˜¯æ³¨æ„å…¶ä¸­0çš„å¤„ç†ï¼Œå¾ˆç„å¦™

```C
int numDecodings(char* s) {
    if (!s || strlen(s) == 0 || s[0] == '0') return 0;
    int r1 = 1, r2 = 1; // r1: å‰ä¸€ä¸ªå­—ç¬¦ï¼Œ r2ï¼šå‰ä¸¤ä¸ªå­—ç¬¦
    char* p = s++; // ä¸Šä¸€ä¸ªå­—ç¬¦

    while (*s) {
        if (*s == '0')
             r1 = 0; // 0 ä¸èƒ½å•ç‹¬æ„æˆå­—æ¯
        if (*p == '1' || *p == '2' && *s < '7') { // å½¢æˆä¸¤ç§å¯èƒ½
            int t = r1;
            r1 = r2 + r1;
            r2 = t;
        } else {
            r2 = r1; // æ–°åŠ å…¥çš„æ•°å­—åªèƒ½å•ç‹¬æ„æˆå­—æ¯
        }

        p = s++;
    }
    return r1;
}
```

92 åœ¨ç»™å®šåŒºé—´ä¸Šç¿»è½¬æ•°ç»„
------

åŒæ ·æ˜¯æ•°ç»„æ“ä½œç»†èŠ‚é¢˜

```C
struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {
    if (m == n) return head;
    struct ListNode dummy, *p = &dummy, * small_node, * big_node; // actually the prev ones
    dummy.next = head;
    n -= m;

    while (--m) // m starts from 1, so not m--
        p = p->next;
    struct ListNode* start = p->next;
    while (n--) {
        struct ListNode* next = start->next;
        start->next = next->next;
        next->next = p->next;
        p->next = next;
    }

    return dummy.next;
}
```

93 æ¢å¤ IP åœ°å€ï¼Œç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé€‚å½“æ’å…¥ç‚¹ï¼Œä¸€å…±æœ‰å¤šå°‘ç§æ–¹å¼æ„æˆ IP åœ°å€
------

åˆæ˜¯ä¸€é“ DFS çš„é¢˜ï¼Œæ³¨æ„å¯¹äºå­—ç¬¦ä¸²é—®é¢˜å¦‚ä½•å¤„ç†

```C++
vector<string> restoreIpAddresses(string s) {
    vector<string> result;
    restore(result, s, "", 0, 0);
    return result;
}

void restore(vector<string>& result, string& s, string restored, int start, int dots) {
    if (dots > 4) return;
    if (dots == 4 && start == s.size())
        result.push_back(restored);

    for (int i = 1; i < 4; i++) {
        if (start + i > s.size())
            break;
        string part = s.substr(start, i);
        if (part[0] == '0' && part.size() > 1 || i == 3 && stoi(part) > 255)
            continue;
        restore(result, s, restored + part + (dots==3 ? "" : "."), start + i, dots + 1);

    }
}
```

94 ä¸­åºéå†äºŒå‰æ ‘
------

å½“ç„¶æ˜¯ä½¿ç”¨æ ˆäº†

```C++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> stk;
    TreeNode* current = root;

    while (!stk.empty() || current) {
        if (current) {
            stk.push(current);
            current = current->left;
        } else {
            current = stk.top();
            stk.pop();
            result.push_back(current->val);
            current = current->right;
        }
    }
    return result;
}
```

95 ç”ŸæˆäºŒå‰æ ‘ï¼ŒåŒä¸‹é¢˜ä¸€æ ·
------

```C++
vector<TreeNode*> generateTrees(int n) {
    return gen(1, n);
}

vector<TreeNode*> gen(int start, int end) {
    vector<TreeNode*> result;
    if (start > end) {
        result.push_back(NULL);
        return result;
    }

    for (int i = start; i <= end; i++) {
        auto leftTrees = gen(start, i - 1);
        auto rightTrees = gen(i + 1, end);
        for (auto& l : leftTrees) {
            for (auto& r : rightTrees) {
                auto root = new TreeNode(i);
                root->left = l;
                root->right = r;
                result.push_back(root);
            }
        }
    }
    return result;
}
```

96 ç»™å®šæ•°å­—nï¼Œä»1åˆ° n ä½œä¸ºèŠ‚ç‚¹æœ‰å¤šå°‘ç§æ–¹å¼ç”ŸæˆäºŒå‰æ ‘
------

è¿™é“é¢˜çœ‹ä¼¼æ˜¯æ ‘ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªåŠ¨æ€è§„åˆ’é—®é¢˜ã€‚

```C
int numTrees(int n) {
    if (n == 0) return 0;

    int* dp = malloc(sizeof(int) * (n+1));
    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        int num = 0;
        for (int j = 0; j <= i; j++) // ä¾æ¬¡é€‰å–ç¬¬ k ä¸ªç‚¹ä½œä¸ºæ ¹
            num += dp[j - 1] * dp[i - j];
        dp[i] = num;
    }
    return dp[n];
}
```

97 ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²äº¤å‰æ˜¯å¦èƒ½å¤Ÿæ„æˆç¬¬ä¸‰ä¸ªå­—ç¬¦ä¸²
------

è¿™é“é¢˜æ˜¯ä¸€é“äºŒç»´çš„ DP é—®é¢˜ï¼Œå› ä¸ºéœ€è¦å¯¹äºæ¯ä¸ªå­—ç¬¦ä¸²çš„æ¯ä¸ªä½ç½®ç”¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²å°è¯•åŒ¹é…

```C
bool isInterleave(char* s1, char* s2, char* s3) {
    int l1 = strlen(s1), l2 = strlen(s2), l3 = strlen(s3);
    if (l1 + l2 != l3) return false;
    // åœ¨ i+j ä½ç½® s1[i] s2[j] æ˜¯å¦èƒ½å¤Ÿæ„æˆs[i+j]
    bool** dp = malloc(sizeof(bool*) * (l1 + 1));
    for (int i = 0; i <= l1; i++)
        dp[i] = malloc(sizeof(bool) * (l2 + 1));

    for (int i = 0; i <= l1; i++)
        for (int j = 0; j <= l2; j++)
            if (i == 0 && j == 0)
                dp[i][j] = true;
            else if (i == 0)
                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]); // æ³¨æ„ï¼šèµ‹å€¼çš„ä¼˜å…ˆçº§æ›´é«˜
            else if (j == 0)
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]);
            else
                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1] || dp[i][j-1] && s2[j-1] == s3[i+j-1]);
    return dp[l1][l2];
}
```

98 éªŒè¯äºŒå‰æœç´¢æ ‘æ˜¯å¦åˆæ³•
------

å…ˆåºéå†å³å¯

```C
bool valid(struct TreeNode* root, long left, long right) {
    return root == NULL || root->val > left && root->val < right &&
        valid(root->left, left, root->val) &&
        valid(root->right, root->val, right);
}

bool isValidBST(struct TreeNode* root) {
    return valid(root, INT_MIN - 1l, INT_MAX + 1l);
}
```

99 åœ¨äºŒå‰æœç´¢æ ‘ä¸­æœ‰ä¸¤ä¸ªèŠ‚ç‚¹è¢«è°ƒæ¢äº†ï¼Œæ‰¾å‡ºè¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¹¶æ¢å¤è¯¥äºŒå‰æ ‘
------

```C
struct TreeNode* prev = NULL;
struct TreeNode* first = NULL;
struct TreeNode* second = NULL;

void traverse(struct TreeNode* root) {
    if (!root) return;
    traverse(root->left);
    if (prev && prev->val > root->val) {
         if (!first) first = prev;
         second = root;
    }
    prev = root;
    traverse(root->right);
}

void recoverTree(struct TreeNode* root) {
    prev = first = second = NULL;
    traverse(root);
    if (!first) return;
    int temp = first->val;
    first->val = second->val;
    second->val = temp;
}
```

100 åˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„æ ‘
------

```C
bool isSameTree(struct TreeNode *p, struct TreeNode *q) {
    if (p == NULL || q == NULL) {
        return p == q;
    } else {
        return p->val == q->val
            && isSameTree(p->left, q->left)
            && isSameTree(p->right, q->right);
    }
}
```

101 åˆ¤æ–­æ˜¯ä¸æ˜¯å·¦å³å¯¹ç§°çš„æ ‘
------

```C
bool sym(struct TreeNode* left, struct TreeNode* right) {
    if (left && !right || !left && right)
        return false;
    return !left && !right ||
        left->val == right->val &&
        sym(left->left, right->right) &&
        sym(right->left, left->right);
}

bool isSymmetric(struct TreeNode* root) {
    if (!root) return true;
    return sym(root->left, root->right);
}
```

102 äºŒå‰æ ‘å±‚åºéå†
------

```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    vector<TreeNode*> current, next;
    current.push_back(root);
    while (!current.empty()) {
        next.resize(0);
        vector<int> vals;
        for (int i = 0; i < current.size(); i++) {
            if (current[i]->left)
                next.push_back(current[i]->left);
            if (current[i]->right)
                next.push_back(current[i]->right);
            vals.push_back(current[i]->val);
        }
        result.push_back(vals);
        current = next;
    }
    return result;
}
```

103 äºŒå‰æ ‘ ZigZag å±‚åºéå†
------

è¿™é“é¢˜æ›´å¥½çš„åšæ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªæ ˆï¼Œä»è€Œä½¿å¾—æ¯è¡Œçš„é¡ºåºéƒ½æ˜¯ä¸Šä¸€è¡Œçš„ç¿»è½¬

```C++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    vector<TreeNode*> current, next;
    current.push_back(root);
    bool odd = true;
    while (!current.empty()) {
        next.resize(0);
        vector<int> vals;
        for (int i = 0; i < current.size(); i++) {
            if (current[i]->left)
                next.push_back(current[i]->left);
            if (current[i]->right)
                next.push_back(current[i]->right);
            vals.push_back(current[i]->val);
        }
        if (!odd) reverse(vals.begin(), vals.end());
        odd = !odd;
        result.push_back(vals);
        current = next;
    }
    return result;
}
```

104 æ ‘çš„æœ€å¤§æ·±åº¦
------

```C
int maxDepth(struct TreeNode* root) {
    if (!root) return 0;
    int left = maxDepth(root->left), right = maxDepth(root->right);
    return (left > right ?left : right) + 1;
}
```

105 ä»å‰åºéå†å’Œä¸­åºéå†ç”Ÿæˆç”ŸäºŒå‰æ ‘
------

```C
struct TreeNode* build(int* prestart, int* preend, int* instart, int* inend) {
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root->val = *prestart;
    root->left = root->right = NULL;

    if (prestart == preend)
        return root;

    int* root_inorder = instart;
    while (root_inorder <= inend && *root_inorder != *prestart)
        root_inorder++;
    int left_len = root_inorder - instart;
    int right_len = inend - root_inorder;
    if (left_len > 0)
        root->left = build(prestart + 1, prestart + left_len, instart, root_inorder - 1);
    if (right_len > 0)
        root->right = build(prestart + left_len + 1, preend, root_inorder + 1, inend);
    return root;
}
// m always equals n, otherwise it's bad input
struct TreeNode* buildTree(int* preorder, int m, int* inorder, int n) {
    if (n==0) return NULL;
    return build(preorder, preorder + n - 1, inorder, inorder + n - 1);
}
```

106 ä»ä¸­åºéå†å’Œååºéå†ç”ŸæˆäºŒå‰æ ‘
------

```C
struct TreeNode* build(int* instart, int* inend, int* poststart, int* postend) {
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root->val = *postend;
    root->left = root->right = NULL;

    if (poststart == postend)
        return root;

    int* root_inorder = instart;
    while (root_inorder <= inend && *root_inorder != *postend)
        root_inorder++;
    int left_len = root_inorder - instart;
    int right_len = inend - root_inorder;
    if (left_len > 0)
        root->left = build(instart, root_inorder - 1, poststart, poststart + left_len - 1);
    if (right_len > 0)
        root->right = build(root_inorder + 1, inend, poststart + left_len, postend - 1);
    return root;
}
struct TreeNode* buildTree(int* inorder, int m, int* postorder, int n) {
    if (n == 0) return NULL;
    return build(inorder, inorder + n - 1, postorder, postorder +n - 1);
}
```

107 äºŒå‰æ ‘å±‚åºéå†ï¼Œä½†è¦ç”Ÿæˆç¿»è½¬çš„éå†åºåˆ—
------

```C++
vector<vector<int>> levelOrderBottom(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    vector<TreeNode*> current, next;
    current.push_back(root);
    while (!current.empty()) {
        next.resize(0);
        vector<int> vals;
        for (int i = 0; i < current.size(); i++) {
            if (current[i]->left)
                next.push_back(current[i]->left);
            if (current[i]->right)
                next.push_back(current[i]->right);
            vals.push_back(current[i]->val);
        }
        result.push_back(vals);
        current = next;
    }
    reverse(result.begin(), result.end());
    return result;
}
```

108 æŠŠæ’åºæ•°ç»„è½¬åŒ–ä¸ºäºŒå‰æ ‘
------

```C
 struct TreeNode* bst(int* left, int* right) {
    int* mid = left + (right - left) / 2;
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root->val = *mid;
    root->left = root->right = NULL;
    if (left < mid)
        root->left = bst(left, mid-1);
    if (mid < right)
        root->right = bst(mid+1, right);
    return root;
}
struct TreeNode* sortedArrayToBST(int* nums, int n) {
    if (n == 0) return NULL;
    return bst(nums, nums + n -1);
}
```

109 æŠŠæ’åºåˆ—è¡¨è½¬åŒ–ä¸ºäºŒå‰æ ‘
------

```C
struct ListNode* list;
int len(struct ListNode* head) {
    int l = 0;
    while (head)
        head = head->next, l++;
    return l;
}

struct TreeNode* bst(int n) {
    if (n == 0) return NULL;
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root->left = bst(n/2);
    root->val = list->val;
    list = list->next;
    root->right = bst(n - n / 2 - 1);
    return root;
}
struct TreeNode* sortedListToBST(struct ListNode* head) {
    if (!head) return 0;
    list = head;
    return bst(len(head));
}
```

110 å¹³è¡¡äºŒå‰æ ‘
------

```C
int height(struct TreeNode* root) {
    if (!root) return 0;
    int left = height(root->left);
    int right = height(root->right);
    if (left > right + 1 || right > left + 1 || left == -1 || right == -1)
        return -1;
    return (left > right ? left : right) + 1;
}
bool isBalanced(struct TreeNode* root) {
    return height(root) != -1;
}
```

111 äºŒå‰æ ‘æœ€å°é«˜åº¦
------

```C
int minDepth(struct TreeNode* root) {
    if (!root) return 0;
    int left = minDepth(root->left);
    int right = minDepth(root->right);
    if (!right) return left + 1;
    if (!left) return right + 1; // tricky here,å½“æœ‰ç©ºèŠ‚ç‚¹æ—¶ï¼Œä¸èƒ½è¿”å›0ï¼Œè€Œæ˜¯è¿”å›å¦ä¸€ä¸ªå€¼

    return (left < right ? left : right) + 1;
}
```

112 äºŒå‰æ ‘ä¸­æ˜¯å¦å­˜åœ¨å’Œä¸ºæŸä¸ªæ•°çš„è·¯å¾„
------

```C
bool hasPathSum(struct TreeNode* root, int sum) {
    if (!root) return false;
    if (!root->left && !root->right) return sum == root->val;
    return hasPathSum(root->left, sum - root->val) ||
        hasPathSum(root->right, sum - root->val);
}
```

113 æ¥ä¸Šé¢˜ï¼ŒæŠŠè¿™ä¸ªè·¯å¾„æ‰¾å‡ºæ¥
------

```C++
vector<vector<int>> pathSum(TreeNode* root, int sum) {
    vector<vector<int>> result;
    vector<int> path;
    getPaths(result, path, root, sum);
    return result;
}

void getPaths(vector<vector<int>>& result, vector<int> path, TreeNode* root, int sum) {
    if (!root)
        return;
    path.push_back(root->val);
    if (!root->left && !root->right && sum == root->val) {
        result.push_back(path);
        return;
    }

    getPaths(result, path, root->left, sum - root->val);
    getPaths(result, path, root->right, sum - root->val);
}
```

114 æŠŠäºŒå‰æ ‘æ‰å¹³æˆåˆ—è¡¨
------

```C++
TreeNode* prev;
void flatten(TreeNode* root) {
    if (!root) return;
    flatten(root->right);
    flatten(root->left);
    root->right = prev;
    root->left = NULL;
    prev = root; // last flattened element
}
```

115 é€šè¿‡åˆ æ‰ä¸€äº›å­—æ¯å¾—åˆ°å­åºåˆ—ï¼Œé—®æœ‰å¤šå°‘ç§æ–¹æ³•èƒ½å¤Ÿå¾—åˆ°å­åºåˆ—å‘¢
------

ä½¿ç”¨DPï¼Œ

```C++
/**
 * Solution (DP):
 * æˆ‘ä»¬æ‰«æå­—ç¬¦ä¸²s
 * Path[i][j] ä»£è¡¨T.substr(1...i) åœ¨ S(1...j)ä¸åŒçš„å­åºåˆ—çš„æ•°é‡
 *
 * Path[i][j] = Path[i][j-1]            (discard S[j])
 *              +     Path[i-1][j-1]    (S[j] == T[i] and we are going to use S[j])
 *                 or 0                 (S[j] != T[i] so we could not use S[j])
 * while Path[0][j] = 1 and Path[i][0] = 0.
 */


class Solution {
public:
    int numDistinct(string s, string t) {
        int m = t.size();
        int n = s.size();

        if (m > n)
            return 0;
        vector<vector<int>> path(m+1, vector<int>(n+1, 0));

        for (int i = 0; i <= n; i++)
            path[0][i] = 1;

        for (int j = 1; j <= n; j++) // S
            for (int i = 1; i <= m; i++) // T
                path[i][j] = path[i][j-1] + (t[i-1] == s[j-1] ? path[i-1][j-1] : 0);

        return path[m][n];
    }
};
```

116 å®Œå…¨äºŒå‰æ ‘ä¸­æŠŠæ¯ä¸ªèŠ‚ç‚¹æŒ‡å‘ä»–è¿™ä¸€å±‚çš„å³é¢çš„èŠ‚ç‚¹
------

æ˜¾ç„¶å·¦èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€‚

```C
void connect(struct TreeLinkNode *root) {
    if (!root)
        return;
    if (root->left)
        root->left->next = root->right;
    if (root->right)
        root->right->next = root->next ? root->next->left : NULL;
    connect(root->left);
    connect(root->right);
}
```

117 åŒä¸Šé¢˜ï¼Œä½†æ˜¯æ˜¯ä»»æ„çš„ğŸŒ²
------

é€šè¿‡ä¸Šä¸€å±‚å·²ç»è¢«è¿æ¥çš„ next æŒ‡é’ˆï¼Œé¡ºåºå±‚åºè®¿é—®ï¼Œä»è€Œè¿æ¥ä¸‹ä¸€å±‚ã€‚

```C
void connect(struct TreeLinkNode *root) {
    struct TreeLinkNode* head = root, * prev = NULL, *p = NULL;
    while (head) { // head æ˜¯æ¯å±‚çš„å¼€å§‹
        p = head;
        prev = head = NULL;

        while (p) {
            if (p->left) {
                if (prev)
                    prev->next = p->left;
                else
                    head = p->left;
                prev = p->left;
            }

            if (p->right) {
                if (prev)
                    prev->next = p->right;
                else
                    head = p->right;
                prev = p->right;
            }
            p = p->next;
        }
    }
}
```

118 æ¨è¾‰ä¸‰è§’
------

æ³¨æ„åæ ‡å…³ç³»ï¼Œä¸è¦è¢«éª—äº†

```C++
vector<vector<int>> generate(int n) {
    vector<vector<int>> result(n);


    for (int i = 0; i < n; i++) {
        result[i].resize(i+1);
        result[i][0] = result[i][i] = 1;
        for (int j = 1; j < i; j++)
            result[i][j] = result[i-1][j-1] + result[i-1][j];
    }
    return result;
}
```

119 è¿”å›æ¨è¾‰ä¸‰è§’çš„ç¬¬ k è¡Œ
------

è¦æ±‚åªèƒ½ä½¿ç”¨O(k)çš„é¢å¤–ç©ºé—´ï¼Œæ¯”è¾ƒè›‹ç–¼çš„æ˜¯è¿™é‡Œçš„ k æ˜¯ä»0è®¡æ•°çš„ã€‚

```C++
vector<int> getRow(int rowIndex) {
    rowIndex++;
    vector<int> row;
    for (int i = 0; i < rowIndex; i++) {
        vector<int> newRow(i+1);
        newRow[0] = newRow[i] = 1;
        for (int j = 1; j < i; j++)
            newRow[j] = row[j-1] + row[j];
        swap(row, newRow);
    }
    return row;
}
```

120 ç»™å®šä¸€ä¸ªç±»ä¼¼æ¨è¾‰ä¸‰è§’å½¢çŠ¶çš„æ•°ç»„ï¼Œæ±‚ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„æœ€çŸ­è·¯å¾„
------

æ˜¾ç„¶æ˜¯ä½¿ç”¨ DPï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæ˜¯ top down çš„è¯ï¼Œæœ€åè¿˜éœ€è¦éå†ä¸€ä¸‹ï¼Œè€Œå¦‚æœæ˜¯ bottom up å°±åªéœ€è¦è¿”å›dp[0]å°±å¥½äº†ã€‚

```C++
int minimumTotal(vector<vector<int>>& triangle) {
    vector<int> dp(triangle.back()); // å¤åˆ¶æœ€åä¸€è¡Œ
    for (int layer = triangle.size() - 2; layer >= 0; layer--)
        for (int i = 0; i <= layer; i++)
            dp[i] = triangle[layer][i] + min(dp[i], dp[i+1]);
    return dp[0];
}
```

121 ä¹°å–è‚¡ç¥¨æœ€ä½³æ—¶æœºï¼Œåªèƒ½äº¤æ˜“ä¸€æ¬¡
------

```C
int maxProfit(int* prices, int pricesSize) {
    if (pricesSize < 2) return 0;
    int profit = 0;
    int min = prices[0];
    // ä»å‰åˆ°åä¾æ¬¡éå†ï¼Œå¦‚æœæœ‰æ›´å¥½çš„æ”¶ç›Šæ›´æ–°ï¼Œæˆ–è€…æ›´æ–° minï¼Œé™åˆ¶æ¡ä»¶æ˜¯å…ˆå‡ºç°æœ€å°å€¼
    for (int i = 0; i < pricesSize; i++) {
        if (prices[i] > min) {
                profit = max(profit, prices[i] - min);
        } else {
            min = prices[i];
        }
    }
    return profit;
}
```

122 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºï¼Œå¯ä»¥åšä»»æ„å¤šæ¯”äº¤æ˜“
------

æœ‰ä¸¤ç§è§£æ³•ï¼Œä¸€ç§æ˜¯ä¸æ–­åšäº¤æ˜“ï¼Œå®Œå…¨ä¸è€ƒè™‘äº¤æ˜“æ¬¡æ•°ï¼Œè¿™ç§åšæ³•ä¸ç¬¦åˆå®é™…æƒ…å†µã€‚
å¦ä¸€ç§åšæ³•æ˜¯æ¨¡æ‹Ÿäº¤æ˜“ï¼Œè¿™æ ·ä¼šç”Ÿæˆæœ€å°‘çš„äº¤æ˜“æ¬¡æ•°ï¼Œç»“æœä¹Ÿæ˜¯å¯¹çš„ã€‚

```C
// 1
int maxProfit(int* prices, int pricesSize)
    int total = 0;
    for (int i=0; i< pricesSize-1; i++)
        if (prices[i+1]>prices[i])
            total += prices[i+1]-prices[i];

    return total;
}
```

```C
// 2
int maxProfit(int* prices, int pricesSize) {
    if (!prices) return 0;
    int profit = 0;bool buy = true;
    int min = prices[0], max = prices[0];
    for (int i = 0; i < pricesSize; i++) {
        if (prices[i] < min && buy) {
            min = prices[i];
            max = prices[i];
        }
        if (prices[i] > min && buy)
            buy = false;
        if (prices[i] > max && !buy)
            max = prices[i];
        if ((prices[i] < max || i == pricesSize - 1) && !buy){
            profit += max - min;
            min = prices[i];
            max = prices[i];
            buy = true;
        }

    }
    return profit;

}
```

123 è‚¡ç¥¨äº¤æ˜“ï¼Œé™åˆ¶åªèƒ½äº¤æ˜“ä¸¤è‚¡
------

æ¯æ¬¡æ±‚è§£çš„æ˜¯ï¼šå–å‡ºä¸¤è‚¡ä»¥åçš„æœ€å¤§å€¼ï¼Œåˆšåˆšä¹°å…¥ç¬¬äºŒè‚¡çš„æœ€å¤§å€¼ï¼Œå–å‡ºç¬¬ä¸€è‚¡æ—¶å€™çš„æœ€å¤§å€¼ï¼Œä¹°å…¥ç¬¬ä¸€è‚¡æ—¶å€™çš„æœ€å¤§å€¼ã€‚

```C++
int maxProfit(vector<int>& prices) {
    int hold1 = INT_MIN, hold2 = INT_MIN;
    int release1 = 0, release2 = 0;

    for (auto i : prices) {
        release2 = max(release2, hold2 + i);
        hold2 = max(hold2, release1 - i);
        release1 = max(release1, hold1 + i);
        hold1 = max(hold1, -i);
    }

    return release2;
}
```

124 äºŒå‰æ ‘è·¯å¾„æœ€å¤§å’Œï¼Œè·¯å¾„å¯ä»¥ä»ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹åˆ°ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ç»“æŸ
------

```C
int max(int a, int b) {
    return a > b ? a : b;
}

int doSum(struct TreeNode* root, int* sum) {
    if (!root)
        return 0;
    int left = max(0, doSum(root->left, sum));
    int right = max(0, doSum(root->right, sum));
    *sum = max(*sum, left+right+root->val);
    return max(left, right) + root->val;
}


int maxPathSum(struct TreeNode* root) {
    int sum = INT_MIN;
    doSum(root, &sum);
    return sum;
}
```

125 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåªè€ƒè™‘å­—æ¯å’Œæ•°å­—ï¼Œå¿½ç•¥å¤§å°å†™ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯å›æ–‡å­—ç¬¦ä¸²
------

å¤ªç®€å•äº†ï¼Œæ²¡å•¥å¯è¯´çš„

```C
bool isPalindrome(char* s) {
    int len = strlen(s);
    if (len == 0) return true;
    int left = 0, right = len - 1;
    while (left < right) {
        char l = s[left], r = s[right];
        if (isalnum(l) && isalnum(r)) {
            if (tolower(l) != tolower(r))
                return false;
            left++, right--;
        } else {
            if (!isalnum(l))
                left++;
            if (!isalnum(r))
                right--;
        }
    }
    return true;
}
```

127 å•è¯æ¢¯å­
------

ç»™å®šæ¢¯å­ï¼Œå’Œå¼€å§‹å•è¯å’Œç»“æŸå•è¯ï¼Œæœ€å°‘éœ€è¦å¤šå°‘ä¸ªä¸­é—´å•è¯ï¼Œæ‰èƒ½å˜åŒ–è¿‡å»ï¼Œæ¯æ¬¡åªèƒ½å˜åŒ–ä¸€ä¸ªå­—æ¯

```C++
int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {
    unordered_set<string> beginSet, endSet, *set1, * set2;
    beginSet.insert(beginWord);
    endSet.insert(endWord);

    int dist = 2;
    while (!beginSet.empty() && !endSet.empty()) {
        if (beginSet.size() < endSet.size()) {
            set1 = &beginSet;
            set2 = &endSet;
        } else {
            set1 = &endSet;
            set2 = &beginSet;
        }

        unordered_set<string> temp;
        for (auto word : *set1) { // notice word in not ref
            wordList.erase(word);
            for (auto& letter : word) {
                for (int i = 0; i < 26; i++) {
                    char oldLetter = letter;
                    letter = 'a' + i;
                    if (set2->find(word) != set2->end())
                        return dist;
                    if (wordList.find(word) != wordList.end()) {
                        temp.insert(word);
                        wordList.erase(word);
                    }
                    letter = oldLetter;
                }
            }
        }
        dist++;
        swap(*set1, temp);

    }
    return 0;
}
```

128 æœ€é•¿é€’å¢å­åºåˆ—
------

ä½¿ç”¨åŠ¨æ€è§„åˆ’

```C++
int longestConsecutive(vector<int>& nums) {
    int result = 0;
    unordered_map<int, int> hash; // æ¯ä¸ªå…ƒç´ å’Œå®ƒä»¬æ‰€åœ¨åºåˆ—çš„é•¿åº¦

    for (auto n : nums) {
        if (hash.find(n) == hash.end()) {
            // æŸ¥æ‰¾ä¸¤è¾¹çš„å…ƒç´ ï¼Œå¦‚æœæ‰¾åˆ°ï¼ŒæŠŠæ–°å…ƒç´ åˆå¹¶è¿›å»
            int left = hash.find(n-1) != hash.end() ? hash[n-1] : 0;
            int right = hash.find(n+1) != hash.end() ? hash[n+1] : 0;
            int sum = left + right + 1;
            hash[n] = hash[n-left] = hash[n+right] = sum; // æ³¨æ„æ­¤å¤„çš„æ›´æ–°ï¼Œå¹¶ä¸éœ€è¦æ›´æ–°åŒºé—´å†…çš„æ¯ä¸ªå€¼ï¼Œåªéœ€è¦æ›´æ–°è¾¹ç•Œå³å¯
            result = max(result, sum);
        }
    }

    return result;
}
```

129 äºŒå‰æ ‘ä¸­åªæœ‰0-9æ‰¾å‡ºæ‰€æœ‰æ ¹èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹çš„å’Œ
------

```C
int sum(struct TreeNode* root, int x) {
    if (!root->left && !root->right)
        return x * 10 + root->val;
    int val = 0;
    if (root->left)
        val += sum(root->left, x * 10 + root->val);
    if (root->right)
        val += sum(root->right, x * 10 + root->val);
    return val;
}

int sumNumbers(struct TreeNode* root) {
    if (!root) return 0;
    return sum(root, 0);
}
```

130 æŠŠæ‰€æœ‰è¢«åŒ…å›´çš„Oç½®ä¸ºX
------

ä½¿ç”¨å¹¶æŸ¥é›†

```C++
class UnionFind {
private:
    vector<int> m_father, m_rank;
public:
    UnionFind(int n): m_father(n), m_rank(n, 0) {
        for (int i = 0; i < m_father.size(); i++)
            m_father[i] = i;
    }

    int find(int x) {
        if (x != m_father[x])
            m_father[x] = find(m_father[x]);
        return m_father[x];
    }

    void unionify(int x, int y) {
        x = find(x);
        y = find(y);

        if (x == y) return;

        if (m_rank[x] > m_rank[y]) {
            m_father[y] = x;
        } else {
            if (m_rank[x] == m_rank[y])
                m_rank[y]++;
            m_father[x] = y;
        }
    }
};

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        if (n == 0) return;
        int m = board[0].size();
        UnionFind uf(n*m+1);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if ((i == 0 || j == 0 || i == n-1 || j == m-1) && board[i][j] == 'O')
                    uf.unionify(i * m + j, n * m);
                else if (board[i][j] == 'O') {
                    if (board[i-1][j] == 'O')
                        uf.unionify(i * m + j, (i - 1) * m + j);
                    if (board[i+1][j] == 'O')
                        uf.unionify(i*m+j, (i+1)*m+j);
                    if (board[i][j-1] == 'O')
                        uf.unionify(i*m+j, i*m+j-1);
                    if (board[i][j+1] == 'O')
                        uf.unionify(i*m+j, i*m+j+1);
                }
            }
        }

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (uf.find(i*m+j) != uf.find(n*m))
                    board[i][j] = 'X';
    }
};
```

131 å¯¹å­—ç¬¦ä¸²åˆ†ç»„ï¼Œæ˜¯çš„æ¯ä¸ªå­—ä¸²éƒ½æ˜¯å›æ–‡ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„åˆ†ç»„
------

```C++
vector<vector<string>> partition(string s) {
    vector<vector<string>> result;
    vector<string> group;
    dfs(result, s, group, 0);
    return result;
}

void dfs(vector<vector<string>>& result, const string& s, vector<string>& group, int start) {
    if (start == s.size()) {
        result.push_back(group);
        return;
    }

    for (int i = start; i < s.size(); i++) {
        if (isPalindrome(s, start, i)) {
            group.push_back(s.substr(start, i - start + 1));
            dfs(result, s, group, i + 1);
            group.pop_back();
        }
    }
}

bool isPalindrome(const string& s, int left, int right) {
    while (left < right) {
        if (s[left++] != s[right--])
            return false;
    }
    return true;
}
```

132 å¦‚ä¸Šé¢˜ï¼Œæ‰¾å‡ºæœ€å°‘éœ€è¦åˆ†ç»„å‡ æ¬¡
------

```C++
int minCut(string s) {
    vector<int> cut(s.size() + 1, 0);
    for (int i = 0; i < s.size() + 1; i++)
        cut[i] = i - 1;

    for (int i = 0; i < s.size(); i++) {
        for (int j = 0; i - j >= 0 && i + j < s.size() && s[i+j] == s[i-j]; j++)
            cut[i+j+1] = min(cut[i+j+1], cut[i-j] + 1); // i-j -> i+jæ˜¯ palindromeï¼Œæ‰€ä»¥åªéœ€è¦cut[i-j] åœ¨åŠ ä¸Šè¿™ä¸€æ®µå°±å¥½äº†
        for (int j = 1; i - j + 1 >= 0 && i + j < s.size() && s[i+j] == s[i-j+1]; j++)
            cut[i+j+1] = min(cut[i+j+1], cut[i - j + 1] + 1);
    }

    return cut[s.size()];
}
```

133 å¤åˆ¶æœ‰å‘å›¾
------

```C++
unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> hash; // old -> new pair
UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
    if (!node)
        return NULL;
    if (hash.find(node) == hash.end()) {
        hash[node] = new UndirectedGraphNode(node->label);
        for (auto n : node->neighbors)
            hash[node]->neighbors.push_back(cloneGraph(n));
    }

    return hash[node];
}
```

134 åŠ æ²¹ç«™
------

```C
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {
    int total = 0;
    int j = -1;

    for (int i = 0, sum = 0; i < gasSize; ++i) {
        sum += gas[i] - cost[i]; // ä»æ­¤å¤„ç»è¿‡èƒ½å¤Ÿå‡€å¢å¤šå°‘æ±½æ²¹
        total += gas[i] - cost[i]; // è®°å½•æ€»çš„æ±½æ²¹é‡æ˜¯å¦æ˜¯æ­£çš„
        if (sum < 0) { // å¦‚æœå½“å‰æ±½æ²¹é‡å·²ç»å°äº 0ï¼Œè¯´æ˜ä¹‹å‰çš„èŠ‚ç‚¹éƒ½æ˜¯ä¸è¡Œçš„ï¼Œåˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            j = i;
            sum = 0; // åŒæ—¶é‡æ–°å¼€å§‹è®¡æ•°
        }
    }

    return total >= 0 ? j + 1 : -1;
}
```

135 ç³–å—ï¼Œæˆç»©é«˜çš„éœ€è¦æ¯”ä»–èº«è¾¹æˆç»©ä½çš„è·å¾—æ›´å¤šçš„ç³–
------

```C++
int candy(vector<int>& ratings) {
    int n = ratings.size();
    if (n <= 1)
        return n;
    vector<int> candies(n, 1);

    for (int i =1; i < n; i++)
        if (ratings[i] > ratings[i-1])
            candies[i] = candies[i-1] + 1;

    for (int i = n - 1; i > 0; i--)
        if (ratings[i-1] > ratings[i])
            candies[i-1] = max(candies[i] + 1, candies[i-1]);

    int result = 0;
    for (auto i : candies)
        result += i;

    return result;
}
```

136 æ‰¾å‡ºæ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—
------

```C
int singleNumber(int* nums, int numsSize) {
    int result = nums[0];
    for (int i = 1; i < numsSize; i++)
        result ^= nums[i];
    return result;
}
```

137 ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œæ‰€æœ‰æ•°å­—éƒ½å‡ºç°ä¸‰æ¬¡ï¼Œé™¤äº†ä¸€ä¸ªæ•°å­—ä»¥å¤–ï¼Œæ‰¾å‡ºè¿™ä¸ªæ•°å­—
------

```C
// ä½¿ç”¨äºŒè¿›åˆ¶è®¡ç®—
// 00->10->01->00(0->1->2->3/0)
// ones = ones ^ A[i]; if (twos == 1) then ones = 0
// twos = twos ^ A[i]; if (ones* == 1) then twos = 0

int singleNumber(int* nums, int numsSize) {
    int ones = 0, twos = 0;
    for (int i = 0; i < numsSize; i++) {
        ones = (ones ^ nums[i]) & ~twos;
        twos = (twos ^ nums[i]) & ~ones;
    }
    return ones;
}
```

138 å¤åˆ¶å¤æ‚ç»“æ„é“¾è¡¨
------

```C
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     struct RandomListNode *next;
 *     struct RandomListNode *random;
 * };
 */
struct RandomListNode *copyRandomList(struct RandomListNode *head) {
    struct RandomListNode* p;
    p = head;
    while (p) {
        struct RandomListNode* node = malloc(sizeof(struct RandomListNode));
        node->next = node->random = NULL; // spicial notice to struct initialization in c
        node->label = p->label;
        node->next = p->next;
        p->next = node;
        p = node->next;
    }

    p = head;
    while (p) {
        if (p->random)
            p->next->random = p->random->next;
        p = p->next->next;
    }

    struct RandomListNode dummy, *q = &dummy;
    dummy.next = dummy.random = NULL;
    p = head;
    while (p) {
        q->next = p->next;
        q = q->next;
        p->next = p->next->next;
        p = p->next;
    }
    return dummy.next;
}
```

139 æŸ¥æ‰¾å•è¯æ˜¯å¦èƒ½ç»„æˆå¥å­
------

```C++
bool wordBreak(string s, unordered_set<string>& wordDict) {
    if (wordDict.empty()) return false;
    vector<bool> dp(s.size() + 1, false);
    dp[0] = true;
    // åŠ¨æ€è§„åˆ’ï¼Œå‡è®¾å‰ i ä¸ªå­—ç¬¦å·²ç»åŒ¹é…åˆ°äº†ï¼Œå°è¯•åŒ¹é… i åˆ° i+jï¼Œå¦‚æœæ‰¾åˆ°äº†ï¼Œå°±åŒ¹é…åˆ°äº† i+j
    for (int i = 1; i <= s.size(); i++) {
        for (int j = i-1; j >= 0; j--) {
            if (dp[j]) {
                string word = s.substr(j, i-j);
                if (wordDict.find(word) != wordDict.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }
    }
    return dp[s.size()];
}
```

141 åˆ—è¡¨æ˜¯å¦æœ‰ç¯
------

slowæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œè€Œfastæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œå› æ­¤åœ¨è¿›å…¥ç¯ä¹‹åï¼Œä¸¤è€…ä¸€å®šä¼šç›¸é‡

```C
bool hasCycle(struct ListNode *head) {
    struct ListNode* slow = head, * fast = head;
    while (fast && fast->next && fast->next->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (slow == fast)
            return true;
    }
    return false;
}
```

142 åˆ—è¡¨æ˜¯å¦æœ‰ç¯ï¼Ÿå¦‚æœæœ‰æ‰¾åˆ°ç¯çš„å¼€å§‹
------

ä»ä¸¤è€…å‡ºå‘ï¼Œåˆ°ä¸¤è€…ç›¸é‡ï¼ŒslowæŒ‡é’ˆèµ°äº†pæ­¥ï¼Œè€ŒfastæŒ‡é’ˆèµ°äº†2pæ­¥ï¼Œæ˜¾ç„¶fastå¤šèµ°äº†ä¸€åœˆï¼ˆæˆ–è€…å¤šåœˆï¼‰ã€‚
è®¾ p = k + x, 2p = k + x + loop -> 2k + 2x = k + x + loop -> k + x = loop -> k = loop - xï¼Œå‰©ä¸‹çš„é•¿åº¦æ­£å¥½ä¹Ÿæ˜¯kã€‚
å‡è®¾å…¥å£å¤„è·ç¦»èµ·ç‚¹çš„è·ç¦»æ˜¯kï¼Œé‚£ä¹ˆå‘ç”Ÿç¢°æ’çš„ç‚¹è·ç¦»ç¯çš„å…¥å£å¤„è·ç¦»ä¹Ÿæ˜¯kï¼Œæ‰€ä»¥ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»å¼€å§‹å’Œç¢°æ’ç‚¹å‡ºå‘åŒ€é€Ÿä¸€å®šä¼šåœ¨ç¯çš„å…¥å£ç›¸é‡ã€‚

```C
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode* slow = head, * fast = head, *entry = NULL;
    bool found = false;
    while (!found && fast && fast->next && fast->next->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (slow == fast)
            found = true;
    }

    if (!found) return NULL;

    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    return slow;
}
```

144 å‰åºéå†
------

```C++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    stack<TreeNode*> stk;
    stk.push(root);

    while (!stk.empty()) {
        TreeNode* node  = stk.top();
        stk.pop();
        result.push_back(node->val);
        if (node->right)
            stk.push(node->right);
        if (node->left)
            stk.push(node->left);

    }

    return result;

}
```

145 ååºéå†
------

```C++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    stack<TreeNode*> stk, output;
    stk.push(root);
    while (!stk.empty()) {
        auto node = stk.top();
        stk.pop();
        output.push(node);

        if (node->left)
            stk.push(node->left);
        if (node->right)
            stk.push(node->right);
    }
    while (!output.empty()) {
        result.push_back(output.top()->val);
        output.pop();
    }
    return result;
}
```

146 LRUç¼“å­˜
------

```C++
class LRUCache{
public:
typedef unordered_map<int, pair<int, list<int>::iterator>> cache_t; // k: v, iter

    LRUCache(int capacity) : m_capacity(capacity) {

    }

int get(int key) {
        auto it = m_cache.find(key);
        if (it == m_cache.end())
             return -1;
        touch(it);
        return it->second.first;
    }

    void set(int key, int value) {
        auto it = m_cache.find(key);
        if (it != m_cache.end()) {
            touch(it);
        } else {
            if (m_cache.size() == m_capacity) {
                m_cache.erase(m_used.back());
                m_used.pop_back();
            }
            m_used.push_front(key);
        }
        m_cache[key] = {value, m_used.begin()};
    }
private:
    void touch(cache_t::iterator it) {
        int key = it->first;
        m_used.erase(it->second.second);
        m_used.push_front(key);
        it->second.second = m_used.begin();
    }

    cache_t m_cache;
    list<int> m_used;
    int m_capacity;
};
```

147 é“¾è¡¨æ’å…¥æ’åº
------

```C
struct ListNode* insertionSortList(struct ListNode* head) {
    if (!head) return NULL;
    struct ListNode dummy, *p = head;
    dummy.val = INT_MIN;
    dummy.next = NULL;
    while (p) {
        struct ListNode* iter = &dummy;
        while (iter->next && iter->next->val < p->val)
            iter = iter->next;
        struct ListNode* pnext = p->next;
        p->next = iter->next;
        iter->next = p;
        p = pnext;
    }
    return dummy.next;
}
```

148 æ’åºé“¾è¡¨ï¼Œè¦æ±‚è¾¾åˆ°O(nlogn)æ—¶é—´å¤æ‚åº¦
------

```C
void split(struct ListNode* source, struct ListNode** frontptr, struct ListNode** backptr) {
    struct ListNode* fast, * slow;
    if (!source || !source->next)
        *backptr = source;
    else {
        slow = source;
        fast = source->next;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;

        }

        *backptr = slow->next;
        slow->next = NULL;
    }
    *frontptr = source;
}

struct ListNode* merge(struct ListNode* l1, struct ListNode* l2) {
    if (l1 == NULL) return l2;
    if (l2 == NULL) return l1;
    struct ListNode dummy;
    dummy.next == NULL;
    struct ListNode* p = &dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            p->next = l1;
            l1 = l1->next;
        } else {
            p->next = l2;
            l2 = l2->next;
        }

        p = p->next;
    }

    if (l1)
        p->next = l1;

    if (l2)
        p->next = l2;

    return dummy.next;
}

// merge sort
struct ListNode* sortList(struct ListNode* head) {
    struct ListNode* front, * back;
    if (!head || !head->next) return head;
    split(head, &front, &back);
    front = sortList(front);
    back = sortList(back);
    head = merge(front, back);
    return head;
}
```

149 åœ¨åŒä¸€æ¡çº¿ä¸Šçš„ç‚¹æœ€å¤šçš„çº¿
------

```C++
int maxPoints(vector<Point>& points) {
    if (points.size() < 2) return points.size();
    int result = 0;

    // å¯¹äºæ¯ä¸€ä¸ªç‚¹
    for (int i = 0; i < points.size(); i++) {
        // ç»è¿‡è¯¥ç‚¹çš„ç›´çº¿ï¼Œä½¿ç”¨åˆ†æ•°ä½œä¸ºæ–œç‡ï¼Œé¿å…ä½¿ç”¨æµ®ç‚¹æ•°
        map<pair<int, int>, int> lines;
        int localMax = 0, overlap = 0;
        for (int j = i + 1; j < points.size(); j++) { // é¿å…é‡å¤è®¡ç®—
            if (points[j].x == points[i].x && points[j].y == points[i].y) {
                overlap++; // åŒä¸€ä¸ªç‚¹
                continue;
            } else {
                int x = points[j].x - points[i].x;
                int y = points[j].y - points[i].y;
                int g = gcd(x, y);
                x /= g, y /= g; // verticle case: x == 0 -> (0, 1)
                lines[make_pair(x, y)]++;
                localMax = max(localMax, lines[make_pair(x, y)]);
            }
        }
        // overlapç®—åœ¨ä»»æ„æ¡çº¿ä¸Š
        result = max(result, localMax + overlap + 1);
    }
    return result;
}

int gcd(int x, int y) {
    if (y == 0) return x;
    else return gcd(y, x % y);
}
```

150 åç¼€è¡¨è¾¾å¼æ±‚å€¼
------

```C++
bool is_operator(char t) {
    return t == '+' || t == '-' || t == '*' || t == '/';
}
int calc(int left, char op, int right) {
    switch(op) {
        case '+': return left + right;
        case '-': return left - right;
        case '*': return left * right;
        case '/': return left / right;
    }
}
int evalRPN(vector<string>& tokens) {
    stack<int> nums;
    for (auto& token : tokens) {
        if (is_operator(token[0]) && token.size() == 1) {
            char op = token[0];
            int right_num = nums.top();
            nums.pop();
            int left_num = nums.top();
            nums.pop();
            nums.push(calc(left_num, op, right_num));
        } else {
            nums.push(stoi(token));
        }
    }
    return nums.top();
}
```

151 åè½¬å¥å­ä¸­çš„å•è¯é¡ºåº
------

ä¸€èˆ¬é¢è¯•çš„æ—¶å€™ä¼šå‡å®šæ²¡æœ‰å¤šä½™å­—ç¬¦çš„ï¼Œè§£æ³•æ˜¯

```C
```

LeetCodeéœ€è¦å¤„ç†å¤šä½™ç©ºæ ¼ï¼š

```C
void swap(char *a, char *b) {
    char tmp = *a; *a = *b; *b = tmp;
}

void reverse(char* start, char* end) {
    while(start < end)
        swap(start++, end--);
}

void trim(char* s) {

    char* fast, *slow;
    for (fast = s; *fast !='\0'; fast++) {
        if (isspace(*fast)) {
            while(isspace(*(fast + 1)) && *(fast + 1) != 0)
                fast++;
            if(*(fast+1) == 0)
                break;
            if(slow == s)
                continue;
        }
        swap(fast, slow++);
    }
    *slow = 0;
}

void reverseWords(char *s) {
    int len = strlen(s);
    if (len == 0)
        return;
    trim(s);
    len = strlen(s);
    if (len == 0)
        return;
    reverse(s, s + len - 1);
    char* head = s, * tail =s ;
    while (*(tail + 1) != '\0') {
        tail = head;
        while (!isspace(*(tail + 1)) && *(tail + 1) != '\0')
            tail++;
        reverse(head, tail);
    }
}
```

152 æœ€å¤§å­åºåˆ—ä¹˜ç§¯
------

```C
int maxProduct(vector<int>& A) {
    int n = A.size();
    int r = A[0];
    for (int i = 1, imax = r, imin = r; i < n; i++) {
        if (A[i] < 0)
            swap(imax, imin);

        imax = max(A[i], imax * A[i]);
        imin = min(A[i], imin * A[i]);

        r = max(r, imax);
    }
    return r;
}
```

153 åœ¨æ—‹è½¬æ•°ç»„ä¸­æŸ¥æ‰¾æœ€å°å€¼
------

```C
int findMin(int* A, int n) {
    int left = 0; int right = n - 1;
    while (left < right - 1) {
        int mid = left + (right - left) / 2;
        if (A[left] > A[mid])
            right = mid;
        else if (A[right] < A[mid])
            left = mid;
        else
            right = mid;
    }
    return A[left] < A[right] ? A[left] : A[right];
}
```

154 åœ¨æ—‹è½¬æ•°ç»„ä¸­æŸ¥æ‰¾æœ€å°å€¼ï¼Œå¯èƒ½æœ‰é‡å¤
------

```C
int findMin(int* A, int n) {
    int left = 0, right = n - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (A[mid] > A[right]) { // å½“éœ€è¦æ‰¾çš„æ˜¯ leftï¼Œä¹Ÿå°±æ˜¯è¾ƒå°çš„æ•°å­—ï¼Œä½¿ç”¨ right æ¯”è¾ƒä¸éœ€è¦ç­‰äºå·
            left = mid + 1;
        } else if (A[right] < A[mid]) {
            right = mid;
        } else {
            right--;
        }
    }
    return A[left];
}
```

155 è®¾è®¡ä¸€ä¸ªæ ˆï¼Œåœ¨æ™®é€šæ ˆçš„åŸºç¡€ä¸Šæ”¯æŒ getmin æ“ä½œ
------

è§£æ³•1: ä½¿ç”¨é¢å¤–çš„æ ˆï¼Œæ¯ä¸ªå€¼éƒ½è®°å½•ä¸€ä¸ªå½“å‰æœ€å°å€¼ï¼Œæµªè´¹ç©ºé—´

è§£æ³•2: ä¹Ÿæ˜¯ä½¿ç”¨é¢å¤–çš„æ ˆï¼Œä½†æ˜¯æƒ°æ€§è®°å½•ï¼Œåªæœ‰å½“éœ€è¦æ›´æ–°çš„æ—¶å€™æ‰å»è®°å½•

```C++
class MinStack {
private:
    stack<int> m_stk;
    stack<int> m_min;
public:
    void push(int x) {
        if (x <= getMin())
            m_min.push(x);
        m_stk.push(x);
    }

    void pop() {
        if (m_stk.top() == getMin())
            m_min.pop();
        m_stk.pop();
    }

    int top() {
        return m_stk.top();
    }

    int getMin() {
        return m_min.empty() ? INT_MAX : m_min.top();
    }
};
```

156-159 Locked

160 æ±‚ä¸¤ä¸ªé“¾è¡¨çš„äº¤å‰ç‚¹
------

åˆ†æé¢˜ç›®å¯çŸ¥ï¼Œå¦‚æœæœ‰ä¸€ä¸ªäº¤å‰ç‚¹ï¼Œé‚£ä¹ˆåœ¨è¿™ä¹‹åçš„æ‰€æœ‰ç‚¹éƒ½æ˜¯äº¤å‰çš„ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸å·§å¦™
çš„åšæ³•ã€‚ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œå¦‚æœåˆ°è¾¾ç»“å°¾å°±æŒ‡å‘å¦ä¸€ä¸ªé“¾è¡¨ï¼Œä¼šäº§ç”Ÿä¸€ä¸‹ä¸‰ç§æƒ…å†µï¼š

1. å¦‚æœäº¤å‰ç‚¹å‰é¢çš„èŠ‚ç‚¹æ•°ç›®ç›¸åŒï¼Œæ˜¾ç„¶ä¼šè¿”å›æ­£ç¡®èŠ‚ç‚¹ã€‚
2. å¦‚æœä¸åŒå‡è®¾ A çš„èŠ‚ç‚¹ä¸º a + cï¼ŒB çš„èŠ‚ç‚¹ä¸º b + cï¼Œåˆ™åœ¨ä¸‹ä¸€æ¬¡éå†æ—¶ï¼š
    a + c + b == b + c + aï¼Œæ°å¥½åˆ°è¾¾ç›¸åŒéƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹ C1
3. å¦‚æœä¸¤ä¸ªåˆ—è¡¨ä¸ç›¸äº¤ï¼Œé‚£ä¹ˆç»è¿‡ a + b, b + aè·ç¦»åï¼Œæ°å¥½éƒ½ç­‰äº NULL

```C
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if (!headA || !headB) return NULL;
    struct ListNode *p1 = headA, *p2=headB;
    while (p1 != p2) {
        // ä¸¤ä¸ªåˆ—è¡¨æ‰‹å°¾ç›¸æ¥ï¼Œå¦‚æœæœ‰ä¸€ä¸ªç‚¹ç›¸åŒï¼Œä¸€å®šä¼šè¿”å›
        // a + c + b == b + c + a   --> C1
        // a + b == b + a    --> NULL
        p1 = p1 ? p1->next : headB;
        p2 = p2 ? p2->next : headA;
    }

    return p1;
}
```

161 Locked

162  æ‰¾åˆ°æå¤§å€¼ï¼Œç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå¯èƒ½æœ‰å¤šä¸ªæå¤§å€¼ï¼Œæ‰¾åˆ°ä»»æ„ä¸€ä¸ªå³å¯ï¼Œç»™å®šæ•°ç»„ä¸­A[i] != A[i+1]
------

é¢˜ç›®è¦æ±‚åœ¨å¯¹æ•°æ—¶é—´å†…åšå‡ºæ¥ï¼ŒäºŒåˆ†æœç´¢ï¼Œå¦‚æœä¸­é—´çš„æ•°åœ¨å·¦åŠéƒ¨åˆ†ï¼Œå°±å‘å³æ‰¾ã€‚

```C
int findPeakElement(int* nums, int numsSize) {
    int left = 0, right = numsSize - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[mid + 1]) // mid in left part of summit
            left = mid + 1;
        else                           // mid in right part of summit
            right= mid;
    }
    return left;
}
```

163 Locked

164 æœªæ’åºæ•°ç»„ä¸­ç›¸å·®æœ€å¤§çš„ä¸¤ä¸ªæ•°ä¹‹é—´çš„å·®
------

æ ¹æ®æŠ½å±‰åŸç†ï¼Œæœ€å¤§å·®ä¸å¯èƒ½å°äº(max - min) / (n - 1)ã€‚è¯æ˜ï¼šå¦‚æœå°äºï¼Œé‚£ä¹ˆæ•´ä¸ªæ•°ç»„çš„å¤§å°å°±ä¼šå°äºmax - minã€‚
å› æ­¤æˆ‘ä»¬æŠŠ

165 æ¯”è¾ƒç‰ˆæœ¬å·å¤§å°
------

```C++
vector<int> ver(const string& version) {
    vector<int> result;
    int num = 0;
    for (auto c : version) {
        if (c != '.') {
            num = num * 10 + c - '0';
        } else {
            result.push_back(num);
            num = 0;
        }
    }
    // å¯¹äºæ‰€æœ‰è¿™ç§åˆ†å‰²ç¬¦ä¸­è¯»å–æ•°å­—çš„éƒ½éœ€è¦æ³¨æ„æœ€åä¸€ä¸ª
    result.push_back(num); // notice here
    return result;
}

int compareVersion(string version1, string version2) {
    auto v1 = ver(version1);
    auto v2 = ver(version2);

    for (int i = 0; i < v1.size() || i < v2.size(); i++) {
        int a = i < v1.size() ? v1[i] : 0;
        int b = i < v2.size() ? v2[i] : 0;
        if (a != b)
            return a > b ? 1 : -1;
    }

    return 0;
}
```

166 åˆ†æ•°ç”Ÿæˆå°æ•°
------

```C++
string fractionToDecimal(long numerator, long denominator) {
    if (numerator == 0) return "0";
    string result;

    // ç¬¦å·
    if (numerator < 0 ^ denominator < 0)
        result += "-";
    long n = abs(numerator), d = abs(denominator);

    // æ•´æ•°éƒ¨åˆ†
    result += to_string(n / d);
    if (n % d == 0) return result;

    // å°æ•°éƒ¨åˆ†
    result+= ".";
    unordered_map<int, int> map;
    for (long r = n % d; r != 0; r %= d) { // æ¨¡æ‹Ÿæ‰‹å·¥é™¤æ³•
        if (map.count(r) > 0) {
            result.insert(map[r], 1, '(');
            result += ")";
            break;
        }

        map[r] = result.size(); // è®°å½•å¯¹åº”çš„ä½ç½®ï¼Œä»¥ä¾¿æ’å…¥æ‹¬å·
        r *= 10; // ä»ä¸Šå€Ÿä½
        result += to_string(r / d);
    }
    return result;
}
```

167 Locked

168 ç”Ÿæˆ Excel è¡¨æ ¼æ ‡é¢˜
------

æ³¨æ„ A å¯¹åº”çš„æ˜¯1è€Œä¸æ˜¯0ï¼Œè€Œä¸”æ•°å­—ä¹Ÿæ˜¯ä»1å¼€å§‹çš„

```C++
string convertToTitle(int n) {
    string title;
    while (n) {
        char c = (n-1) % 26 + 'A';
        n = (n-1) / 26;
        title = c + title;
    }
    return title;
}
```

169 ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæœ‰ä¸€ä¸ªæ•°å­—çš„å‡ºç°é¢‘ç‡è¶…è¿‡äº†ä¸€åŠï¼Œæ‰¾å‡ºè¿™ä¸ªæ•°å­—
------

éå¸¸ç»å…¸çš„ä¸€é“é¢˜ï¼Œé¦–å…ˆæˆ‘ä»¬å‡è®¾æ‹¿åˆ°çš„æ•°å­—å°±æ˜¯ç›®æ ‡ï¼Œå¹¶è®°å½•ä»–å‡ºç°çš„æ¬¡æ•°ï¼Œå¦‚æœä¸‹ä¸€ä¸ª
æ•°å­—å’Œä»–ä¸ä¸€æ ·ï¼Œé‚£ä¹ˆæˆ‘ä»¬å‡ä¸€ï¼Œå½“æ¬¡æ•°ä¸º0çš„æ—¶å€™ï¼Œæˆ‘ä»¬çŸ¥é“è¿™ä¸ªæ•°å­—åœ¨å·²ç»éå†è¿‡çš„æ•°å­—
ä¸­å‡ºç°å°äºä¸€åŠäº†ï¼Œè¿™æ—¶å€™æˆ‘ä»¬æ¢ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œæœ€åå‰©ä¸‹çš„ä¸€å®šæ˜¯è¶…è¿‡ä¸€åŠçš„æ•°å­—ã€‚

```C++
int majorityElement(vector<int>& nums) {
    int candidate, count = 0;
    for (auto i : nums) {
        if (count == 0 || candidate == i) {
            count++;
            candidate = i;
        } else {
            count--;
        }
    }
    return candidate;
}
```

170 Locked

171 Excel æ ‡é¢˜è½¬æ¢ä¸ºæ•°å­—
------

åŒæ ·ï¼Œæˆ‘ä»¬éœ€è¦æ³¨æ„ A å¯¹åº”çš„æ˜¯1ï¼Œè€Œä¸æ˜¯0

```C
int titleToNumber(char* s) {
    int result = 0;
    while (*s)
        result = result * 26 + *s++ - 'A' + 1;
    return result;
}
```

172 é˜¶ä¹˜ä¸­èƒ½æœ‰å‡ ä¸ª0
------

æ˜¾ç„¶å…ˆç®—å‡ºé˜¶ä¹˜æ•°å­—æ˜¯ä¼šæº¢å‡ºçš„ï¼Œè€Œæœ‰0çš„è¯ï¼Œå°±æ˜¯éœ€è¦10ï¼Œä¹Ÿå°±æ˜¯å°±éœ€è¦2å’Œ5ï¼Œ
æ˜¾ç„¶2æ˜¯æ¯”5å¤šçš„ã€‚é‚£ä¹ˆæˆ‘ä»¬åªè¦è€ƒè™‘5çš„ä¸ªæ•°å°±è¡Œäº†ï¼Œ è¿™æ—¶å€™éœ€è¦æ³¨æ„ï¼Œ5/15ç­‰æ˜¯ç®—ä¸€ä¸ª5ï¼Œ
è€Œ25/75åŒ…å«äº†ä¸¤ä¸ª5ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¡ç®—çš„æ—¶å€™ï¼Œæ•°ä¸€éåŒ…å«5çš„ï¼ˆè¿™æ—¶25ç­‰ä¹Ÿè¢«è®¡ç®—äº†ï¼‰ï¼Œ
ç„¶åå†æ•°ä¸€éåŒ…å«25çš„å°±åƒå½“äºæ•°äº†ä¸¤æ¬¡äº†ã€‚

```C
int trailingZeroes(int n) {
    if (n < 0)
        return -1;
    int fives = 0;
    for (int i = 5; n / i > 0; i *= 5)
        fives += n / i;
    return fives;
}
```

173 äºŒå‰æ ‘ä¸­åºéå†è¿­ä»£å™¨
------

```C
class BSTIterator {
public:
    BSTIterator(TreeNode *root) {
        pushAll(root);
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !m_stack.empty();

    }

    /** @return the next smallest number */
    int next() {
        TreeNode* temp = m_stack.top();
        m_stack.pop();
        pushAll(temp->right);
        return temp->val;
    }

private:
    stack<TreeNode*> m_stack;
    void pushAll(TreeNode* root) {
        while (root) {
            m_stack.push(root);
            root = root->left;
        }
    }
};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
 */
```

174 åœ°ä¸‹åŸæ¸¸æˆ
------

ç‹å­åœ¨æ ¼å­çš„å·¦ä¸Šè§’ï¼Œéœ€è¦åˆ°å³ä¸‹è§’å»æ•‘å…¬ä¸»ï¼Œåœ¨è¿‡ç¨‹ä¸­ç‹å­ä¸èƒ½æ­»æ‰ï¼Œå’Œæœºå™¨äººèµ°è·¯ä¸€æ ·ï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’

```C++
int calculateMinimumHP(vector<vector<int>>& dungeon) {
    int row = dungeon.size();
    int col = dungeon[0].size();
    vector<vector<int>> bloods(row + 1, vector<int> (col + 1, INT_MAX));
    bloods[row][col-1] = bloods[row-1][col] = 1; // å…¬ä¸»çš„ä¸¤è¾¹
    // ä»å…¬ä¸»é‚£é‡Œé€†å‘æ¨
    for (int i = row-1; i >= 0; i--) {
        for (int j = col-1; j >= 0; j--) {
             int need = min(bloods[i+1][j], bloods[i][j+1]) - dungeon[i][j]; // ç¼ºä¹çš„è¡€é‡ = åˆ°è¾¾ä¸‹ä¸€æ­¥æœ€å°‘çš„è¡€é‡ - è¿™ä¸€æ­¥æ¶ˆè€—çš„è¡€é‡
             bloods[i][j] = need > 0 ? need : 1; // ç‹å­çš„è¡€é‡è‡³å°‘ä¸º1
        }
    }
    return bloods[0][0];
}
```

175-178 Missing
------

179 æœ€å¤§çš„æ•°å­—
------

ç¥å¥‡çš„æ’åºæ–¹æ³•

```C++
string largestNumber(vector<int>& nums) {
    vector<string> num_strings(nums.size());
    for (int i = 0; i < nums.size(); i++)
        num_strings[i] = to_string(nums[i]);
    auto comparator = [] (string& s1, string& s2) {
        return s1 + s2 > s2 + s1;
    };
    sort(num_strings.begin(), num_strings.end(), comparator);
    string result;
    for (auto& num_string: num_strings)
        result += num_string;
    int start = result.find_first_not_of("0");
    if (start == string::npos) return "0";
    return result.substr(start);
}
```

180-185 Missing
------

186 Locked

187 æ‰¾åˆ°æ‰€æœ‰10ä¸ªå­—æ¯å”±çš„é‡å¤DNAåºåˆ—
------

```C++
// naive çš„åšæ³•ä»å‰å¾€åï¼Œè®°å½•å­—ç¬¦ä¸²
// è§‚å¯Ÿ ATCG å››ä¸ªå­—ç¬¦çš„ç‰¹å¾ï¼Œå¹¶æŠŠä»–ä»¬ç¼–ç ä¸ºä¸€ä¸ªint
// åä¸ªå­—ç¬¦æ­£å¥½ç¼–ç åœ¨ 32bit çš„ int ä¸­
vector<string> findRepeatedDnaSequences(string s) {
    unordered_map<int, int> hash;
    vector<string> result;
    for (int t = 0, i = 0; i < s.size(); i++)
        // å·¦ç§»å¼¹å‡ºè€å…ƒç´ ï¼Œæ±‚äº¤ä¸ºäº†åªä½¿ç”¨30bitï¼Œæ±‚æˆ–æ·»åŠ æ–°å…ƒç´ ã€‚
        if (hash[t = t << 3 & 0x3FFFFFFF | s[i] & 0b111]++ == 1) // ç­‰äº1ä¸ºäº†é¿å…é‡å¤
            result.push_back(s.substr(i - 9, 10));
    return result;
}
```

189 ç¿»è½¬æ ‘ç»„
------

```C
void reverse(int* nums, int left, int right) {
    while (left < right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
        right--;
    }

}

void rotate(int* nums, int numsSize, int k) {
    if (k >= numsSize) k %= numsSize;
    if (k <= 0) return;
    reverse(nums, 0, numsSize - k - 1);
    reverse(nums, numsSize - k, numsSize - 1);
    reverse(nums, 0, numsSize - 1);
}
```

190 ç¿»è½¬äºŒè¿›åˆ¶è¡¨ç¤º
------


```C
uint32_t reverseBits(uint32_t n) {
    uint32_t r = 0;
    int len = sizeof(n) * 8 - 1;
    while (len--) { // 31 times shift
        r |= n & 0x1;
        n >>= 1;
        r <<= 1; // only shift 31 times
    }

    r |= n & 0x1;
    return r;
}
```

191 æ•°å­—äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°
------

æˆ‘ä»¬çŸ¥é“n&(n-1)ä¼šæŠŠ n ä¸­çš„æœ€åä¸€ä¸ª1å»æ‰ï¼Œæ‰€ä»¥å¾ªç¯ç›´åˆ° n ä¸º0å³å¯

```C
int hammingWeight(uint32_t n) {
    int count = 0;
    while (n) {
        n &= n - 1;
        count++;
    }
    return count;
}
```

è¿˜å¯ä»¥é‡‡ç”¨æŸ¥è¡¨æ³•ï¼Œå¯¹äºè¡¨æˆ‘ä»¬å¯ä»¥é¢„å…ˆæ„é€ ï¼Œæˆ–è€…åˆ©ç”¨ä¸Šä¸€ä¸ªæ–¹æ³•ç”Ÿæˆï¼Œå¯¹äºé•¿åº¦è¿‡å¤§çš„ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†å—æŸ¥è¡¨ã€‚

```C
#include <stdio.h>
#include <stdlib.h>

int counts[16];

int _get_count(n) {
    int count = 0;
    while (n) {
        n &= n-1;
        count++;
    }
    return count;
}

int init_counts() {
    for (int i = 0; i < 16; i++)
        counts[i] = _get_count(i);
};

int get_count(n) {
    int count = 0;
    while (n) {
        int index = n & 0xF;
        count += counts[index];
        n >>= 4;
    }
    return count;
}

int main() {
    init_counts();
    for (int i = 0; i < 100; i++)
        printf("%d: %d\n", _get_count(i), get_count(i));
    return 0;
}
```

192-197 Missing

198  æœ‰ä¸€æ’æˆ¿å­ï¼Œæ¯ä¸ªæˆ¿å­ä¸­éƒ½æœ‰ä¸€å®šè´¢äº§ï¼Œä½†æ˜¯ä¸èƒ½å·ç›¸é‚»çš„ä¸¤ä¸ªæˆ¿å­ï¼Œæ±‚èƒ½å·åˆ°çš„æœ€å¤§å€¼
------

ä½¿ç”¨ DPï¼Œå¯¹äºæ¯ä¸ªæˆ¿å­ï¼Œå¯ä»¥é€‰æ‹©ä¸å·æˆ–è€…å‰ i-1ä¸ªæˆ¿å­åŠ ä¸Šå·å½“å‰æˆ¿å­ï¼Œå³`dp[i+1]
= max(dp[i], dp[i-1] + A[i])`

```C
int rob(int* nums, int numsSize) {
    if (!nums) return 0;
    // å› ä¸ºä¸èƒ½ç›¸é‚»ï¼Œæ‰€ä»¥å¯ä»¥ä»ç›¸éš”ä¸€ä¸ªçš„å–å€¼
    // dp[n] = max(dp[n-1], dp[n-2] + A[n])
    int temp, m = 0, n = nums[0];
    for (int i = 1; i < numsSize; i++) {
        temp = n;
        if (m + nums[i] > n)
            n = m + nums[i];
        m = temp;
    }
    return n;
}
```

199 ä»å³è¾¹çœ‹äºŒå‰æ ‘çš„æ•ˆæœ
------

```C++
// level order éå†
vector<int> rightSideView(TreeNode* root) {
    vector<int> result;
    if (!root)
        return result;
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node;
        int len = q.size(); // ä¿å­˜ä¸ºäº†è·å¾—æœ€åä¸€ä¸ªå…ƒç´ 
        for (int i = 0; i < len; i++) { // å½“å‰æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ å°±æ˜¯æœ€å³è¾¹çš„å…ƒç´ 
            node = q.front();
            q.pop();
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
        result.push_back(node->val);
    }
    return result;
}
```

200 æ‰¾å‡ºå°å²›çš„æ•°é‡
------

é‡‡ç”¨å¹¶æŸ¥é›†ï¼Œæ‰¾åˆ°æœ€åé›†åˆçš„æ•°é‡

```C++
class UnionFind {
private:
    vector<int> m_father, m_rank;
    int m_count; // sets count
public:
    UnionFind(int n): m_father(n), m_rank(n, 0), m_count(n) {
        for (int i = 0; i < m_father.size(); i++)
            m_father[i] = i;
    }

    int find(int x) {
        if (x != m_father[x])
            m_father[x] = find(m_father[x]);
        return m_father[x];
    }

    void unionify(int x, int y) {
        x = find(x);
        y = find(y);

        if (x == y) return;

        if (m_rank[x] > m_rank[y]) {
            m_father[y] = x;
        } else {
            if (m_rank[x] == m_rank[y])
                m_rank[y]++;
            m_father[x] = y;
        }
        m_count--;
    }

    int getCount() {
        return m_count;
    }
};

class Solution {
const static char LAND = '1';
const static char WATER = '0';

public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty())
            return 0;
        int r = grid.size(), c = grid[0].size();
        UnionFind uf(r * c + 1); // extra element is for water
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (grid[i][j] == LAND) {
                    if (i != r - 1 && grid[i+1][j] == LAND)
                         uf.unionify(i*c+j, (i+1)*c+j);
                    if (j != c - 1 && grid[i][j+1] == LAND)
                         uf .unionify(i*c+j, i*c+j+1);
                } else {
                    uf.unionify(i*c+j, c*r);
                }
            }
        }
        return uf.getCount() - 1; // islands + water - 1;
    }
};
```

201 ç»™å®šåŒºé—´å†…ï¼Œæ‰€æœ‰æ•°å­—ANDçš„ç»“æœ
------

æ˜¾ç„¶ç›´æ¥è¿‡ä¸€éæ˜¯ä¼šè¶…æ—¶çš„ï¼Œé‚£ä¹ˆåˆ†æå¯çŸ¥

```C
// å¦‚æœä¸¤ä¸ªæ•°ä¸ç›¸ç­‰ï¼Œä¸€å®šæ˜¯æœ‰ä¸åŒçš„ä½ï¼Œé‚£ä¹ˆè¿™ä¸€ä½ä¸€å®šä¸º0
int rangeBitwiseAnd(int m, int n) {
    int t = 0;
    while (m != n) {
        t++;
        m >>= 1;
        n >>= 1;
    }
    return m << t;
}
```

202 å¿«ä¹æ•°å­—ï¼Œå„ä½æ•°å­—å¹³æ–¹ç›¸åŠ å¾—åˆ°ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå¦‚æœæœ€åç­‰äº1
------

æ²¡å•¥ï¼Œä¸€ç›´ç®—å°±å¯ä»¥äº†ã€‚ã€‚

```C++
bool isHappy(int n) {
    while (n > 6) {
        int next = 0;
        while (n) {
            next += (n%10) * (n%10);
            n /= 10;
        }
        n = next;
    }
    return n == 1;
}
```

203 åˆ é™¤é“¾è¡¨ä¸­ç»™å®šçš„å€¼
------

```C
struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode dummy, *p = &dummy;
    dummy.next = head;
    while (p) {
        if (p->next && p->next->val == val) { // not forward here
            struct ListNode* next = p->next;
            p->next = next->next;
            free(next);
        } else {
            p = p->next;
        }

    }
    return dummy.next;
}
```

204 æ‰¾å‡ºç´ æ•°
------

ä»€ä¹ˆç­›å­ï¼Œå¿˜äº†

```C++
int countPrimes(int n) {
    vector<bool> primes(n, true);
    primes[0] = primes[1] = false;

    for (int i = 2; i * i < n; i++) // æ³¨æ„ï¼Œåªåˆ°sqrt(n)
        if (primes[i])
            for (int j = i * i; j < n; j += i) // ä» i * i å¼€å§‹ï¼Œå› ä¸ºi* i--å·²ç»è¢«æ€è¿‡äº†
                primes[j] = false;

    int count = 0;
    for (int i = 2; i < n; i++)
        if (primes[i])
            count++;
    return count;
}
```

205 åŒæ„å­—ç¬¦ä¸²ï¼Œå¯ä»¥çœ‹ä½œword patternçš„ç®€åŒ–
------

```C
bool isIsomorphic(char* s, char* t) {
    int ss[256] = { 0 };
    int ts[256] = { 0 };
    if (strlen(s) != strlen(t))
        return false;
    int i = 0;
    while (s[i]) {
        if (ss[s[i]] != ts[t[i]])
            return false;
        ss[s[i]] = ts[t[i]] = i + 1;
        i++;
    }
    return true;
}
```

206 åè½¬é“¾è¡¨
------

```C
struct ListNode* reverseList(struct ListNode* head) {
    if (!head || !head->next)
        return head;
    struct ListNode *p = NULL, *cur = head, *next;

    while (cur) {
        next = cur->next; // cache
        cur->next = p; // reverse pointing
        p = cur; // moves forwards
        cur = next;
    }
    return p;
}
```

```C
// recursive
```

207 æ ‡å‡†çš„æ‹“æ‰‘æ’åº
------

ç»™å®šè¾¹è¿™ç§æ–¹æ³•è¡¨ç¤ºå›¾ä¹Ÿæ˜¯é†‰äº†

```C++
bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) { // next -> before
    vector<unordered_set<int>> graph(numCourses); // æ¯æ¡è¾¹å’Œä»–çš„ä¸‹ä¸€æ­¥ï¼Œä¸´æ¥è¡¨
    for (auto& p : prerequisites)
        graph[p.second].insert(p.first);

    vector<int> d(numCourses, 0); // in degree

    for (auto& nexts : graph)
        for (auto next : nexts)
            d[next]++;

    for (int i = 0; i < numCourses; i++) {
        int nondep; // in degree == 0
        for (nondep = 0; nondep < numCourses && d[nondep] != 0; nondep++)
            ;
        if (nondep == numCourses)
            return false;
        d[nondep] = -1; // remove
        for (auto next : graph[nondep]) // æ‰€æœ‰ä¸‹ä¸€æ­¥éƒ½ ï¼1
            d[next]--;
    }

    return true;
}
```


208 å®ç°å‰ç¼€æ ‘
------

```C++
class TrieNode {
public:
    static const int branchCount = 26;
    bool isWord;
    TrieNode* next[branchCount];
    // Initialize your data structure here.
    TrieNode() : isWord(false) {
        for (int i = 0; i < branchCount; i++)
            next[i] = NULL;
    }
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string word) {
        TrieNode* location = root;
        for (auto& c : word) {
            if (!location->next[c - 'a'])
                location->next[c - 'a'] = new TrieNode;
            location = location->next[c - 'a'];
        }
        location->isWord = true;
    }

    // Returns if the word is in the trie.
    bool search(string word) {
        TrieNode* location = root;
        for (auto& c : word) {
            location = location->next[c - 'a'];
            if (!location)
                return false;
        }
        return location->isWord;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) {
        TrieNode* location = root;
        for (auto& c : prefix) {
            location = location->next[c - 'a'];
            if (!location)
                return false;
        }
        return true;
    }

private:
    TrieNode* root;
};

// Your Trie object will be instantiated and called as such:
// Trie trie;
// trie.insert("somestring");
// trie.search("key");
```

209 æœ€çŸ­å­æ•°ç»„ä½¿å¾—å’Œå¤§äºæŸä¸ªæ•°
------

åŒæŒ‡é’ˆï¼Œè¶…è¿‡å’Œä¹‹åå†å°è¯•ä»å¼€å§‹å¤„å‡å»å…ƒç´ 

```C++
int minSubArrayLen(int s, vector<int>& nums) {
    int start = 0, sum = 0, len = INT_MAX;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        while (sum >= s) {
            len = min(len, i - start + 1);
            sum -= nums[start++];
        }
    }

    return len == INT_MAX? 0 : len;
}
```

210 Course Schedule II
------

BFS

```C++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);
        vector<int> degrees = compute_indegree(graph);
        queue<int> zeros;
        for (int i = 0; i < numCourses; i++)
            if (!degrees[i]) zeros.push(i);
        vector<int> toposort;
        for (int i = 0; i < numCourses; i++) {
            if (zeros.empty()) return {};
            int zero = zeros.front();
            zeros.pop();
            toposort.push_back(zero);
            for (int neigh : graph[zero]) {
                if (!--degrees[neigh])
                    zeros.push(neigh);
            }
        }
        return toposort;
    }
private:
    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<unordered_set<int>> graph(numCourses);
        for (auto pre : prerequisites)
            graph[pre.second].insert(pre.first);
        return graph;
    }
    vector<int> compute_indegree(vector<unordered_set<int>>& graph) {
        vector<int> degrees(graph.size(), 0);
        for (auto neighbors : graph)
            for (int neigh : neighbors)
                degrees[neigh]++;
        return degrees;
    }
};
```

211 æ·»åŠ å’Œæœç´¢å­—ç¬¦ä¸²
------

```C++
class TrieNode {
public:
    static const int branchCount = 26;
    bool isWord;
    TrieNode* next[branchCount];
    // Initialize your data structure here.
    TrieNode() : isWord(false) {
        for (int i = 0; i < branchCount; i++)
            next[i] = NULL;
    }
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string word) {
        TrieNode* location = root;
        for (auto& c : word) {
            if (!location->next[c - 'a'])
                location->next[c - 'a'] = new TrieNode;
            location = location->next[c - 'a'];
        }
        location->isWord = true;
    }

    // Returns if the word is in the trie.
    virtual bool search(string word) {
        TrieNode* location = root;
        for (auto& c : word) {
            location = location->next[c - 'a'];
            if (!location)
                return false;
        }
        return location->isWord;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) {
        TrieNode* location = root;
        for (auto& c : prefix) {
            location = location->next[c - 'a'];
            if (!location)
                return false;
        }
        return true;
    }

    TrieNode* getRoot() {
        return root;
    }

private:
    TrieNode* root;
};


class WordDictionary : public Trie{

public:
    WordDictionary() : Trie(){}

    // Adds a word into the data structure.
    void addWord(string word) {
        insert(word);
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    bool search(string word) override {
        return search(word.c_str(), getRoot());
    }

    bool search(const char* word, TrieNode* root) {
        TrieNode* run = root;
        for (int i = 0; word[i]; i++) {
            if (run && word[i] != '.')
                run = run->next[word[i] - 'a'];
            else if (run && word[i] == '.') {

                // skip checking this char
                TrieNode* tmp = run;
                for (int j = 0; j < 26; j++) {
                    run = tmp->next[j];
                    if (search(word + i + 1, run))
                        return true;
                }
            }
            else break;
        }
        return run && run->isWord;
    }
};

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary;
// wordDictionary.addWord("word");
// wordDictionary.search("pattern");
```

212 å•è¯æœç´¢
------

Trieç»“æ„è§å‰é¢ï¼Œæ³¨æ„è¦è®°å½•visitedï¼Œè¿˜æœ‰è¾¹ç•Œçš„é—®é¢˜ï¼Œå¦å¤–é›†åˆçš„ä½¿ç”¨

```C++
class Solution {
private:
    Trie m_trie;
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        for (auto& word : words)
            m_trie.insert(word);
        int row = board.size();
        int col = board[0].size();

        unordered_set<string> result_set;
        vector<vector<bool>> visited(row, vector<bool>(col, false));
        for (int i = 0; i < row; i++)
            for(int j = 0; j < col; j++)
                find(result_set, board, visited, "", i, j);
        vector<string> result;
        for (auto& r : result_set)
            result.push_back(r);
        return result;
    }

    void find(unordered_set<string>& r, vector<vector<char>>& board, vector<vector<bool>>& visited, string word, int i, int j) {
        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || visited[i][j])
            return;
        word += board[i][j];
        if (!m_trie.startsWith(word))
            return;
        if (m_trie.search(word))
            r.insert(word);

        visited[i][j] = true;
        find(r, board, visited, word, i-1, j);
        find(r, board, visited, word, i+1, j);
        find(r, board, visited, word, i, j-1);
        find(r, board, visited, word, i, j+1);
        visited[i][j] = false;

    }

};
```

213 å°å·å·ç¯çŠ¶æ•°ç»„
------

```C
int max(int a, int b) {
    return a > b ? a : b;
}

int robNonCyclic(int* nums, int numsSize) {
    if (!nums) return 0;
    // å› ä¸ºä¸èƒ½ç›¸é‚»ï¼Œæ‰€ä»¥å¯ä»¥ä»ç›¸éš”ä¸€ä¸ªçš„å–å€¼
    // dp[n] = max(dp[n-1], dp[n-2] + A[n])
    int temp, m = 0, n = nums[0];
    for (int i = 1; i < numsSize; i++) {
        temp = n;
        if (m + nums[i] > n)
            n = m + nums[i];
        m = temp;
    }
    return n;
}

int rob(int* nums, int numsSize) {
    return max(robNonCyclic(nums, numsSize - 1), robNonCyclic(nums + 1, numsSize - 1));
}
```


214 æœ€çŸ­å›æ–‡å­—ç¬¦ä¸²ï¼Œç»™æŒ‡å®šçš„å­—ç¬¦ä¸²æ·»åŠ å­—æ¯è·å¾—å›æ–‡
------

```C++
// based on kmp next array
string shortestPalindrome(string s) {
    string rev_s = s;
    reverse(rev_s.begin(), rev_s.end());
    string l = s + "#" + rev_s;

    vector<int> p(l.size(), 0);
    for (int i = 1; i < l.size(); i++) {
        int j = p[i - 1];
        while (j > 0 && l[i] != l[j])
            j = p[j - 1];
        p[i] = (j += l[i] == l[j]);
    }

    return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;
}
```

215 æ•°ç»„ä¸­ç¬¬kå¤§çš„æ•°å­—
------

å®é™…ä¸Šè¿™é“é¢˜æ›´å¯èƒ½çš„é¢˜ç›®æ˜¯æ‰¾åˆ°å‰kå¤§çš„æ‰€æœ‰æ•°å­—ã€‚
é¦–å…ˆï¼Œè®¾è®¡åˆ°æ•°ç»„æ’åºçš„é—®é¢˜ä¸€å®šå‘é¢è¯•å®˜è¦é—®æ¸…æ¥šæ•°æ®é‡çš„å¤§å°ï¼Œè¿™å½±å“åˆ°æ¥ä¸‹æ¥çš„å®ç°ï¼Œ
åŒæ—¶å’Œé¢è¯•å®˜æ¢è®¨æ•°æ®é‡å¤§å°å¯¹å®ç°çš„å½±å“ï¼Œæœ‰åŠ©äºæ›´å¥½çš„æŠŠæ¡å±€é¢ã€‚

æˆ‘ä»¬å…ˆå‡è®¾æ•°æ®é‡æ˜¯æ¯”è¾ƒå°çš„ï¼Œä¹Ÿå°±æ˜¯èƒ½å¤Ÿæ”¾åˆ°å†…å­˜ä¸­ã€‚

0. ä½¿ç”¨æ’åºå°±å®åœ¨æ˜¯naiveäº†ï¼Œä¸è¿‡é¢è¯•å®˜éè¦é—®çš„è¯ï¼Œå½“ç„¶æ˜¯ä½¿ç”¨é€‰æ‹©æ’åºæ›´å¥½äº†ã€‚
1. ä½¿ç”¨å¿«æ’ä¸­çš„partitionç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦O(n*logk)ã€‚
2. ä½¿ç”¨sizeä¸ºkçš„å †ï¼Œæ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯O(n*logk)ï¼Œä¸ç®¡æ•°å­—å¤šå¤§ï¼Œéƒ½åªéœ€è¦éå†ä¸€éã€‚
3. ä½¿ç”¨ç±»ä¼¼æ’å…¥æ’åºçš„æ–¹æ³•ï¼Œä¿æŒæ•°ç»„å¤§å°ä¸å˜ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n*k)ã€‚
4. æ•°æ®çš„èŒƒå›´æœ‰é™æ—¶å€™ï¼Œä½¿ç”¨è®¡æ•°æ’åºã€‚

å½“æ•°æ®è¿‡å¤§çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³é€šè¿‡å“ˆå¸Œå–æ¨¡ä¹‹åæŠŠæ–‡ä»¶åˆ†ç»„ï¼Œæ‰¾å‡ºæ¯ä¸ªæ–‡ä»¶ä¸­æœ€å¤§çš„kä¸ªæ•°å­—

å¦‚æœæ•°å­—ä¸­æœ‰é‡å¤å‘¢ï¼Ÿä½¿ç”¨è®¡æ•°æ’åºï¼Œè®¡æ•°å¼ºåˆ¶æŒ‰ä¸€ç®—
å¦‚æœæ—¢æœ‰é‡å¤åˆæ˜¯æµ®ç‚¹æ•°å‘¢ï¼Ÿ

```C
int swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int partition(int* nums, int start, int end) {
    int small = start - 1;
    int pivot = nums[end];
    for (int i = start; i < end; i++)
        if (nums[i] < pivot)
            swap(&nums[++small], &nums[i]);
    swap(&nums[++small], &nums[end]);
    return small;
}

int findKthLargest(int* nums, int numsSize, int k) {
    int left = 0, right = numsSize - 1;
    while (1) {
        int index = partition(nums, left, right);
        if (index == numsSize - k)
            return nums[index];
        if (index > numsSize - k)
            right = index - 1;
        else
            left = index + 1;
    }
}
```

216 æ‰¾åˆ°kä¸ªæ•°å­—[1...9]ï¼Œä½¿å¾—ä»–ä»¬çš„å’Œæ˜¯n
------

```C++
vector<vector<int>> combinationSum3(int k, int n) {
    vector<vector<int>> result;
    dfs(result, {}, n, k);
    return result;
}

void dfs(vector<vector<int>>& result, vector<int> combination, int n, int k) {
    if (combination.size() == k) {
        if (n == 0)
            result.push_back(combination);
        return;
    }
    int i = combination.empty() ? 1 : combination.back() + 1; // ä¿è¯ä¸é‡å¤åˆ‡å®é€’å¢åºåˆ—
    while (i <= n && i < 10) {
        combination.push_back(i);
        dfs(result, combination, n-i, k);
        combination.pop_back();
        i++;
    }
}
```

217 åŒ…å«é‡å¤æ•°å­—
------

è¿™é“é¢˜å¤ªç®€å•äº†ï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆç²¾å¦™çš„è§£æ³•ï¼Œå¯ä»¥ä½¿ç”¨æ’åºï¼ŒHash ç­‰å¤šç§è§£æ³•

```C++
bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> s;
    for (auto& n : nums)
        if (s.find(n) != s.end())
            return true;
        else
            s.insert(n);
    return false;
}
```

218 è·å¾—çŸ©å½¢é‡åˆéƒ¨åˆ†çš„æ‹ç‚¹
------

æŠ„è¿‡æ¥çš„ï¼Œè¿˜æ²¡ä»”ç»†ç ”ç©¶

```C++
vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {
    vector<pair<int, int>> res;
    int cur=0, cur_X, cur_H =-1,  len = buildings.size();
    priority_queue< pair<int, int>> liveBlg; // first: height, second, end time
    while(cur<len || !liveBlg.empty()) { // if either some new building is not processed or live building queue is not empty
        cur_X = liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; // next timing point to process

        if(cur>=len || buildings[cur][0] > cur_X) { //first check if the current tallest building will end before the next timing point
              // pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one
            while(!liveBlg.empty() && ( liveBlg.top().second <= cur_X) ) liveBlg.pop();
        } else { // if the next new building starts before the top one ends, process the new building in the vector
            cur_X = buildings[cur][0];
            while(cur<len && buildings[cur][0]== cur_X)  // go through all the new buildings that starts at the same point
            {  // just push them in the queue
                liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1]));
                cur++;
            }
        }
        cur_H = liveBlg.empty()?0:liveBlg.top().first; // outut the top one
        if(res.empty() || (res.back().second != cur_H) ) res.push_back(make_pair(cur_X, cur_H));
    }
    return res;
}
```

219 åŒ…å«é‡å¤æ•°å­—ï¼Œå¹¶ä¸”ä¸¤ä¸ªçš„åæ ‡ä¸è¶…è¿‡k
------

```C++
// æ»‘åŠ¨çª—å£ä¿å­˜å‰kä¸ªå€¼ï¼Œå¦‚æœæœ‰é‡å¤çš„å°±è¿”å›
// num[i-k] num[i-1]ï¼Œå¦‚æœæ»‘è¿‡äº†ï¼Œå°±åˆ é™¤è¯¥å…ƒç´ 
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    unordered_set<int> s;
    if (k <= 0)
        return false;
    if (k >= nums.size()) // notice here
        k = nums.size() - 1;

    for (int i = 0; i < nums.size(); i++) {
        if (i > k)
            s.erase(nums[i - k - 1]); // delete first note
        if (s.find(nums[i]) != s.end())
            return true;
        s.insert(nums[i]); // insert
    }

    return false;
}
```

220 åŒä¸Šä¸€é¢˜ï¼ŒåŒæ—¶ä¿è¯ä¸¤ä¸ªæ•°å­—ä¹‹é—´å°äºt
------

ä¿è¯ä¸¤ä¸ªæ•°å­—ä¹‹å·®å°äºt

```C++
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
    set<int> window; // æ³¨æ„ä¸èƒ½ä½¿ç”¨unordered
    if (k <= 0)
        return false;
    if (k >= nums.size()) // notice here
        k = nums.size() - 1;
    for (int i = 0; i < nums.size(); i++) {
        if (i > k)
            window.erase(nums[i - k - 1]);
        auto pos = window.lower_bound(nums[i] - t); // notice set.lower_bound
        if (pos != window.end() && *pos - nums[i] <= t)
            return true;
        window.insert(nums[i]);
    }
    return false;
}
```

221 æ‰¾åˆ°æœ€å¤§çš„æ­£æ–¹å½¢
------

ä½¿ç”¨åŠ¨æ€è§„åˆ’ https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space

```C++
int maximalSquare(vector<vector<char>>& matrix) {
    if (matrix.empty()) return 0;
    int m = matrix.size(), n = matrix[0].size();
    vector<int> dp(m + 1, 0);
    int maxsize = 0, pre = 0;
    for (int j = 0; j < n; j++) { // æ¯ä¸€åˆ—
        for (int i = 1; i <= m; i++) { // notice i range
            int temp = dp[i];
            if (matrix[i - 1][j] == '1') {
                dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1;
                maxsize = max(maxsize, dp[i]);
            }
            else dp[i] = 0;
            pre = temp;
        }
    }
    return maxsize * maxsize;
}
```


222 ç»™å®šä¸€ä¸ªå®Œå…¨æ ‘ï¼Œè®¡ç®—èŠ‚ç‚¹çš„æ•°é‡ã€‚
------

```C++
int countNodes(struct TreeNode* root) {
    if (!root)
             return 0;
    int left_height = 0, right_height = 0;
    struct TreeNode* left = root, *right = root;
    while (left) {
        left = left->left;
        left_height++;
    }

    while (right) {
        right = right->right;
        right_height++;
    }

    if (left_height == right_height) // æ»¡æ ‘ 2^h - 1
        return (1 << left_height) - 1;

    return countNodes(root->left) + countNodes(root->right) + 1;
}
```

223 æ‰¾å‡ºä¸¤ä¸ªé•¿æ–¹å½¢è¦†ç›–çš„é¢ç§¯
------

```C
int computeArea(int left1, int down1, int right1, int up1, int left2, int down2, int right2, int up2) {
    int left = max(left1, left2); //é å³çš„
    int right = max(min(right1, right2), left);// é å·¦çš„ï¼Œä½†æ˜¯æ¯”å·¦è¾¹å¤§

    int down = max(down1, down2);
    int up = max(min(up1, up2), down);

    // ä¸å°å¿ƒå†™åäº†ã€‚ã€‚
    return -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));
}
```

224 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒåŒ…å«åŠ å‡å’Œæ‹¬å·ï¼Œè®¡ç®—å€¼
------

éš¾ç‚¹æ˜¯å¯¹æ‹¬å·çš„å¤„ç†ï¼Œæ³¨æ„æ¯æ¬¡éƒ½è¦å’Œsigns.top()ç›¸ä¹˜

```C++
int calculate(string s) {
    stack<int> signs; // signs before braces
    int sign = 1;
    int num = 0;
    int result = 0;

    signs.push(1);
    for (auto c : s) {
        if (isdigit(c)) {
            num = 10 * num + (c - '0');
        } else if (c == '+' || c == '-') {
            result += signs.top() * sign * num;
            num = 0;
            sign = c == '+' ? 1 : -1;
        } else if (c == '(') {
            signs.push(sign * signs.top()); // tricky
            sign = 1;
        } else if (c == ')') {
            result += signs.top() * sign * num;
            num = 0;
            signs.pop();
            sign = 1;
        }
    }

    result += signs.top() * sign * num; // tricky

    return result;
}
```

225 ä½¿ç”¨é˜Ÿåˆ—æ¨¡æ‹Ÿæ ˆ
------

å…¶å®æœ‰ä¸¤ç§åšæ³•ï¼Œä¸€ç§æ˜¯åœ¨pushçš„æ—¶å€™ï¼ŒæŠŠé˜Ÿåˆ—æ¸…ç©ºï¼ŒæŠŠxæ”¾åˆ°æœ€åº•ä¸‹ã€‚
å¦ä¸€ç§æ˜¯åœ¨popçš„æ—¶å€™ï¼ŒæŠŠé˜Ÿåˆ—æ¸…ç©ºåˆ°1ï¼Œç„¶åå¼¹å‡ºã€‚åº”å½“è¯¢é—®é¢è¯•å®˜ç©¶ç«Ÿæ˜¯pushå±…å¤šè¿˜æ˜¯popå±…å¤š

```C++
class Stack {
public:
    // Push element x onto stack.
    void push(int x) {
        while (!nums.empty()) {
            temp.push(nums.front());
            nums.pop();
        }
        nums.push(x);
        while (!temp.empty()) {
            nums.push(temp.front());
            temp.pop();
        }
    }

    // Removes the element on top of the stack.
    void pop() {
        nums.pop();
    }

    // Get the top element.
    int top() {
        return nums.front();
    }

    // Return whether the stack is empty.
    bool empty() {
        return nums.empty();
    }
private:
    queue<int> nums;
    queue<int> temp;
};
```

226 åè½¬äºŒå‰æ ‘
------

```C
struct TreeNode* invertTree(struct TreeNode* root) {
    if (!root) return NULL;
    struct TreeNode* temp = root->left;
    root->left = invertTree(root->right);
    root->right = invertTree(temp);
    return root;
}
```

227 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åŒ…å«+-*/è®¡ç®—ä»–çš„å€¼
------

```C++
int calculate(string s) {
    vector<int> stk; // ä½¿ç”¨vectorä¾¿äºç»Ÿè®¡æœ€åçš„å€¼
    char token = '+';
    int num = 0;
    for (int i = 0; i < s.size(); i++) {
        if (isdigit(s[i]))
            num = num * 10 + s[i] - '0';
        // è¿™é‡Œä¸æ˜¯else if
        if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || i == s.size() - 1) { // æ³¨æ„æœ€åä¸€æ­¥è¿˜éœ€è¦æŠŠæœ€åçš„å€¼è®¡ç®—
            int a;
            switch (token) {
            case '+':
                stk.push_back(num);
                break;
            case '-':
                stk.push_back(-num);
                break;
            case '*':
                a = stk.back();
                stk.pop_back();
                stk.push_back(a * num);
                break;
            case '/':
                a = stk.back();
                stk.pop_back();
                stk.push_back(a / num);
                break;
            };
            token = s[i];
            num = 0;
        }
    }

    int result = 0;
    for (auto i : stk)
        result += i;
    return result;
}
```

228 èšåˆåŒºé—´ï¼Œç»™å®šä¸€æ’åºæ•°ç»„ï¼ŒæŠŠç›¸é‚»çš„æ•°å­—ç”¨åŒºé—´è¡¨ç¤º
------

```C++
vector<string> summaryRanges(vector<int>& nums) {
    int n = nums.size();
    vector<string> result;
    if (n == 0) return result;

    for (int i = 0; i < n; ) {
        int start = i, end = i;
        while (end + 1 < n && nums[end + 1] == nums[end] + 1)
            end++;
        if (end > start)
            result.push_back(to_string(nums[start]) + "->" + to_string(nums[end]));
        else
            result.push_back(to_string(nums[start]));
        i = end + 1;
    }

    return result;
}
```

229 æ‰¾å‡ºè¶…è¿‡ä¸‰åˆ†ä¹‹ä¸€çš„å…ƒç´ 
------

```C++
vector<int> majorityElement(vector<int>& nums) {

    int count1 = 0, count2 = 0;
    int a, b;

    for (auto n : nums) {
        if (count1 == 0 || n == a) {
            count1++;
            a = n;
        } else if (count2 == 0 || n == b) {
            count2++;
            b = n;
        } else {
            count1--;
            count2--;
        }
    }

    count1 = count2 = 0;
    for (int n : nums) {
        if (n == a) count1++;
        if (n == b) count2++;
    }

    vector<int> result;

    if (count1 > nums.size() / 3) // verify a
        result.push_back(a);
    if (count2 > nums.size() / 3 && a != b) // verify b
        result.push_back(b);
    return result;
}
```

230 äºŒå‰æ ‘ä¸­ç¬¬kå°çš„æ•°å­—
------

```C
// ä¼ é€’æŒ‡é’ˆ
void inorder(struct TreeNode* root, int* k, int* number) {
    if (!root)
        return;
    inorder(root->left, k, number);
    (*k)--;
    if (*k == 0) {
        *number = root->val;
        return;
    }
    inorder(root->right, k, number);
}
int kthSmallest(struct TreeNode* root, int k) {
    int number;
    inorder(root, &k, &number);
    return number;
}
```

231 2çš„æ¬¡æ–¹
------

```C
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```

232 ä½¿ç”¨æ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—
------

```C++
class Queue {
public:
    // Push element x to the back of queue.
    void push(int x) {
        in.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        if (empty())
            return;
        if (out.empty())
            transfer();
        out.pop();
    }

    // Get the front element.
    int peek(void) {
        if (empty())
            return INT_MIN;
        if (out.empty())
            transfer();
        return out.top();
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return in.empty() && out.empty();
    }
private:
    void transfer() {
        while (!in.empty()) {
            out.push(in.top());
            in.pop();
        }
    };
    stack<int> in;
    stack<int> out;
};
```

233 å°äºnçš„æ•°å­—ä¸­1çš„ä¸ªæ•°
------

å¯¹äºæ¯ä¸€ä½ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š

1. å½“æ˜¯æ•°å­—0çš„æ—¶å€™ï¼Œå¯èƒ½å‡ºå…ˆ1çš„æƒ…å†µå®Œå…¨ç”±é«˜ä½å‡ºç°å†³å®šï¼Œå› ä¸ºè¿™ä¸€ä½ä¸èƒ½è´¡çŒ®1
2. å½“æ˜¯æ•°å­—1çš„æ—¶å€™ï¼ŒåŒä¸Šï¼Œä½†æ˜¯è¿™ä¸€ä½å’Œä½ä½ä¸€èµ·å¯ä»¥è´¡çŒ®ä¸€ä¸ª1
3. å½“æ—¶æ•°å­—2-9çš„æ—¶å€™ï¼Œç›¸å½“äºè¿™ä¸€ä½çš„1å¯ä»¥ä»»æ„å‡ºç°ï¼Œå› æ­¤é«˜ä½ï¼‹1

```C
int countDigitOne(int n) {
    int ones = 0;
    for (int m = 1; m <= n; m *= 10) { // m is the factor
        int a = n/m, b = n%m;  // a is left half, b is right half
        if (a % 10 >= 2)
            ones += (a / 10 + 1) * m;
        if (a % 10 == 1)
            ones += (a / 10) * m + b + 1;
        if (a % 10 == 0)
            ones += (a / 10) * m;
    }
    return ones;
}
```

äºŒè¿›åˆ¶å‘¢

```C
int countDigitOneBinary(int n) {
    int ones = 0;
    for (int m = 1; m <= n; m <<= 1) {
        int a = n / m, b = n % m;
        if (a & 0x01)
            ones += (a >> 1) * m + b + 1;
        else
            ones += (a >> 1) * m;
    }
}
```

æ±‚æœ€å¤§çš„countDigitOne(n) == n

    9    1
    99   20
    999  300
    ...
    99999999  10000000


234 åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æ˜¯å›æ–‡
------

è§£æ³•1: å¦‚æœé“¾è¡¨æ˜¯å¯ä»¥æ”¹å˜çš„ï¼Œä¸å¦¨åè½¬å®ƒçš„å‰åŠéƒ¨åˆ†ï¼Œç„¶åå†ä¸ååŠéƒ¨åˆ†æ¯”è¾ƒ

è§£æ³•2: å¦‚æœæ˜¯åªè¯»çš„ï¼Œå¤åˆ¶ä¸€ä»½ä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯ä¸å¦‚ä½¿ç”¨å †æ ˆ

æ³¨æ„å¯¹å¥‡æ•°å¶æ•°çš„å¤„ç†

```C++
bool isPalindrome(ListNode* head) {
    if (!head || !head->next)
        return true;
    int len = 0;
    ListNode* temp = head;
    while (temp) {
        len++;
        temp = temp->next;
    }

    stack<int> stk;
    temp = head;
    int mid = len / 2;
    while (mid--) {
        stk.push(temp->val);
        temp = temp->next;
    }

    if (len & 0x01)
        temp = temp->next;

    while (temp != NULL && !stk.empty()) {
        int a = stk.top();
        stk.pop();
        int b = temp->val;
        temp = temp->next;
        if (a != b) {
            return false;
        }
    }

    return true;
}
```

235 äºŒå‰æœç´¢æ ‘å…¬å…±ç¥–å…ˆ
------

```C
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    while (root) {
        if (root->val > p->val && root->val > q->val)
            root = root->left;
        else if (root->val < p->val && root->val < q->val)
            root = root->right;
        else
            return root;
    }
}
```

236 äºŒå‰æ ‘å…¬å…±ç¥–å…ˆ
------

å¦‚æœäºŒå‰æ ‘çš„æ ¹å°±æ˜¯å…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£æ˜¾ç„¶æ˜¯è¿™ä¸ªã€‚
åœ¨ä¸¤é¢—å­æ ‘ä¸­åˆ†åˆ«æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°äº†ï¼Œè¿”å›ä¸€ä¸ªé NULL å€¼ï¼Œå¦‚æœéƒ½æ‰¾åˆ°äº†ï¼Œåˆ™è¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯ LCA

```C
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (!root || root == p || root == q)
        return root;
    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);
    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);

    if (!left) // not in left subtree
        return right;
    if (!right)
        return left;
    return root; // both left and right are found!
}
```

237 åˆ é™¤é“¾è¡¨ä¸­çš„å…ƒç´ 
------

ç›´æ¥å°†åç»§èŠ‚ç‚¹çš„å€¼å¤åˆ¶åˆ°å½“å‰èŠ‚ç‚¹

```C
void deleteNode(struct ListNode* node) {
    if (!node || !node->next)
        return;
    struct ListNode* next = node->next;
    node->val = next->val;
    node->next = next->next;
    free(next);
}
```

238 æ•°ç»„é™¤äº†è‡ªå·±ä»¥å¤–çš„ä¹˜ç§¯ï¼Œè§„å®šä¸èƒ½ç”¨é™¤æ³•
------

é¦–å…ˆä»å‰å¾€åä¹˜ï¼Œé”™å¼€ä¸€ä½å…ƒç´ ï¼Œè¿™æ ·æ¯ä¸ªå…ƒç´ éƒ½ä¹˜åˆ°äº†ä»–ä¹‹å‰çš„æ‰€æœ‰å…ƒç´ ï¼Œæœ€åä¸€ä¸ªå…ƒç´ å·²ç»æ˜¯ç»“æœäº†ã€‚
ç„¶åä»åå¾€å‰ä¹˜ï¼ŒåŒæ ·é”™å¼€ä¸€ä½ï¼Œè¿™æ ·æ¯ä¸ªå…ƒç´ åˆæŠŠä»–ä¹‹åçš„å…ƒç´ éƒ½å¾—åˆ°äº†ã€‚

239 æ»‘åŠ¨çª—å£æœ€å¤§å€¼ï¼Œç»™å®šä¸€ä¸ªæ»‘åŠ¨çª—å£ï¼Œè¿”å›å®ƒç§»åŠ¨è¿‡ç¨‹ä¸­çš„æœ€å¤§å€¼
------

è¿™é“é¢˜å’Œ min stack çš„æ€è·¯å®Œå…¨ä¸€æ ·ï¼Œåªä¸è¿‡æ¢æˆäº† deque

```C++
// é¢˜ç›®ç»™å®š k ä¸€å®šæ˜¯æœ‰æ•ˆåœ°
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    if (nums.empty() || k <= 0)
        return result;
    deque<int> dq; // å­˜å‚¨çš„æ˜¯ç´¢å¼•ï¼Œfront å­˜å‚¨æœ€å¤§å€¼ï¼Œä¿è¯é€’å‡
    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && dq.front() < i - k + 1) // å¼¹å‡ºæ»‘è¿‡çš„çª—å£
            dq.pop_front();
        while (!dq.empty() && nums[dq.back()] < nums[i]) // å¼¹å‡ºå°çš„
            dq.pop_back();
        dq.push_back(i);
        if (i >= k - 1)
            result.push_back(nums[dq.front()]);
    }
    return result;
}
```

240 ç»™å®šä¸€ä¸ªçŸ©é˜µï¼Œæ¯è¡Œä»å·¦åˆ°å³éƒ½æ˜¯å¢å¤§çš„ï¼Œæ¯ä¸€åˆ—ä»ä¸Šåˆ°ä¸‹éƒ½æ˜¯å¢å¤§çš„ï¼Œæ‰¾å‡ºç»™å®šæ•°å­—æ˜¯å¦å­˜åœ¨
------

æˆ‘ä»¬è€ƒè™‘å³ä¸Šè§’çš„å…ƒç´ 

1.å¦‚æœè¿™ä¸ªå…ƒç´ æ¯” taget å¤§ï¼Œé‚£ä¹ˆæ•´åˆ—éƒ½æ¯” target å¤§ï¼Œæˆ‘ä»¬å¯ä»¥ c--
2.å¦‚æœè¿™ä¸ªå…ƒç´ æ¯” target å°ï¼Œé‚£ä¹ˆæ­£è¡Œéƒ½æ¯” target å°ï¼Œæˆ‘ä»¬å¯ä»¥ r++

```C
bool searchMatrix(int** matrix, int row, int col, int target) {
    int r = 0, c = col - 1; // å³ä¸Šè§’
    while (r < row && c > -1) // å‘å·¦ä¸‹è§’
        if (matrix[r][c] == target)
            return true;
        else if (matrix[r][c] > target)
            c--;
        else
            r++;
    return false;
}
```

241 æ·»åŠ æ‹¬å·å¾—åˆ°ä¸åŒçš„ç»“æœ
------

å¯¹æ¯ä¸€ä¸ªç¬¦å·ï¼Œåœ¨ä»–çš„ä¸¤è¾¹æ·»åŠ æ‹¬å·çš„å¥½çš„ä¸åŒç»“æœå†è®¡ç®—ã€‚

```C++
vector<int> diffWaysToCompute(string input) {
    vector<int> output;
    for (int i = 0; i < input.size(); i++) {
        char token = input[i];
        if (!isdigit(token)) // not digit
            for (int a : diffWaysToCompute(input.substr(0, i))) // å·¦åŠéƒ¨åˆ†
                for (int b : diffWaysToCompute(input.substr(i+1))) // å³åŠéƒ¨åˆ†
                    output.push_back(token == '+' ? a + b : token == '-'? a - b: a *b); // ä¸¤åŠéƒ¨åˆ†ä¹‹å’Œ
    }

    if (output.empty())
        output.push_back(stoi(input));
    return output;
}
```

242 ä¸€ä¸ªå•è¯æ˜¯å¦èƒ½ç”±å¦ä¸€ä¸ªå˜å¹»è€Œæ¥
------

è¿˜æ˜¯ï¼Œå¯¹äº ASCII å­—ç¬¦ï¼Œç›´æ¥ç”¨æ•°ç»„ä»£æ›¿å­—å…¸

```C
bool isAnagram(char* s, char* t) {
    char ss[26] = {0};
    char ts[26] = {0};
    while (*s) {
        ss[*s - 'a']++;
        s++;
        ts[*t - 'a']++;
        t++;
    }
    if (*t) return false;
    return memcmp(ss, ts, sizeof(ss)) == 0;
}
```

243-256 Locked

257 äºŒå‰æ ‘å·¦å³è·¯å¾„
------

å…¸å‹çš„ DFSï¼Œå‘æŒ¥æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„

```C++
vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> result;
    if (!root) return result;
    paths(result, "", root);
    return result;
}

void paths(vector<string>& result, string path, TreeNode* root) {
    if (path.empty())
        path += to_string(root->val);
    else
        path += "->" + to_string(root->val);
    if (root->left)
        paths(result, path, root->left);
    if (root->right)
        paths(result, path, root->right);
    if (!root->left && !root->right)
        result.push_back(path);
}
```

258 æŠŠæ•°å­—çš„æ¯ä¸€ä½åŠ èµ·æ¥ï¼Œç›´åˆ°å˜æˆä¸€ä¸ªä¸€ä½çš„æ•°å­—
------

è¿™å®Œå…¨æ˜¯ä¸€é“æ•°å­¦é¢˜ï¼Œå¯¹äºæ¯ä¸ªè¿›åˆ¶çš„æ•°å­—éƒ½æœ‰è§„å¾‹ `(n - 1) % (x - 1) + 1`ã€‚å®é™…ä¸Šæ˜¯æŠŠ10è¿›åˆ¶çš„è½¬åŒ–ä¸º9è¿›åˆ¶æ•°å­—

```C
int addDigits(int num) {
    return (num - 1) % 9 + 1;
}
```

259 Locked

260 ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªæ•°å­—éƒ½æ˜¯é‡å¤çš„ï¼Œåªæœ‰ä¸¤ä¸ªæ•°å­—ä¸æ˜¯ï¼Œæ‰¾å‡ºè¿™ä¸¤ä¸ªæ•°å­—
------

è¿™é“é¢˜å¾ˆå¥‡å¦™ï¼Œä¾ç„¶å¯ä»¥ä½¿ç”¨ XOR æ¥è§£ï¼Œé¦–å…ˆéå†ä¸€éï¼Œè¿™æ—¶å€™ç”±äºæœ‰ä¸¤ä¸ªæ•°å­—æ˜¯ä¸åŒçš„ï¼Œé‚£ä¹ˆä¸€å®šç»“æœä¸ä¸º0ï¼Œé‚£ä¹ˆå…¶ä¸­ä¸€ä¸ª bit ä½ä¸€å®šæ˜¯ä¸€ä¸ªæ•°å­—æœ‰ï¼Œå¦ä¸€ä¸ªæ•°å­—æ²¡æœ‰ã€‚
åœ¨éå†ä¸€éï¼ŒåŒæ—¶æŠŠæ•°å­—åˆ†ä¸¤ç»„ï¼Œä¸€ç»„æ˜¯æœ‰è¿™ä¸ª bit ä½ï¼Œä¸€ç»„æ²¡æœ‰ã€‚å°±å¾—å‡ºäº†ç»“æœã€‚

```C++
vector<int> singleNumber(vector<int>& nums) {
    int r = 0;
    for (auto& n : nums)
        r ^= n;
    int bit = r & -r; // last sig bit

    vector<int> result = {0, 0};
    for (auto& n : nums)
        if (n & bit)
            result[0] ^= n;
        else
            result[1] ^= n;
    return result;
}
```

261 262 Locked

263 ä¸‘é™‹çš„æ•°å­—ï¼Œè´¨æ•°å› å­åªå«æœ‰2,3,5çš„æ•°å­—
------

æŒ‰å®šä¹‰åšå°±å¥½äº†

```C
bool isUgly(int n) {
    if (n <= 0)
        return false;
    if (n == 1)
        return true;
    while (n > 1)
        if (n % 2 == 0)
            n /= 2;
        else if (n % 3 == 0)
            n /= 3;
        else if (n % 5 == 0)
            n /= 5;
        else
            return false;
    return true;
}
```

264 æ‰¾å‡ºç¬¬ n ä¸ªä¸‘é™‹æ•°å­—
------

ä½¿ç”¨æ•°åˆ—è®°å½• n ä¸ªä¸‘é™‹æ•°å­—ï¼Œæ¯ä¸€ä¸ªä¸‘é™‹æ•°å­—è‚¯å®šæ˜¯ä¹‹å‰æ•°å­—ä¹˜ä»¥235å¾—åˆ°çš„ï¼Œç„¶åç”¨ä¸‰ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸Šä¸€ä¸ªåšä¹˜æ³•çš„æ•°å­—ï¼Œæ¯æ¬¡æ‰¾å‡ºæœ€å°çš„ä¸€ä¸ª

```C
#define MIN(a,b) ((a)<(b)?(a):(b))

int nthUglyNumber(int n) {
    if (n <= 0)
        return -1;
    if (n < 6) // 1..6 æ°å¥½éƒ½æ˜¯
        return n;
    int s2 = 0, s3 = 0, s5 = 0;
    int* uglies[n];
    uglies[0] = 1;
    for (int i = 1; i < n; i++) {
        int c2 = uglies[s2] * 2, c3 = uglies[s3] * 3, c5 = uglies[s5] * 5;
        uglies[i] = MIN(c2, MIN(c3, c5));
        if (uglies[i] == c2) s2++;
        if (uglies[i] == c3) s3++;
        if (uglies[i] == c5) s5++;
    }
    return uglies[n-1];
}
```

268 ä¸¢å¤±çš„æ•°å­—ï¼Œç»™å®š0...nï¼Œä¸¢å¤±äº†ä¸€ä¸ªï¼Œç„¶åæ”¾åœ¨é•¿åº¦ä¸º n çš„æ•°ç»„ä¹‹ä¸­ï¼Œæ‰¾å‡ºè¿™ä¸ªæ•°å­—
------

æ˜¾ç„¶è¿˜æ˜¯ä½¿ç”¨å¼‚æˆ–ï¼Œæ³¨æ„ 0 ^ x == xï¼Œæ‰€ä»¥ç›´æ¥æŠŠ 0 å¿½ç•¥å°±è¡Œäº†ã€‚æŠŠæ¯ä¸ªæ•°å­—éƒ½å’Œ i å¼‚æˆ–ï¼Œä¸¢å¤±çš„æ•°å­—å°±å‡ºæ¥äº†

```C
int missingNumber(int* nums, int n) {
    int result = 0;
    for (int i = 0; i < n; i++)
        result = result ^ (i + 1) ^ nums[i];
    return result;
}
```

269-272 Locked

273 æ•°å­—è½¬æ¢ä¸ºè‹±è¯­å•è¯
------

```C++
class Solution {
public:
    vector<string> digits = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    vector<string> tens = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    vector<string> seps = {"", " Thousand ", " Million ", " Billion "}; // notice the trailing spaces

    string numberToWords(int num) {
        if (num == 0)
            return "Zero";
        if (num < 0)
            return "Negative " + numberToWords(-num);
        int count = 0;
        string result;

        while (num) {
            if (num % 1000 != 0)
                result = s2word(num % 1000) + seps[count] + result;
            num /= 1000;
            count++;
        }

        // removw unnecessary tailing space
        if (isspace(result.back()))
            result.resize(result.size() - 1);

        return result;

    }

    string s2word(int num) {
        string result;
        if (num >= 100) {
            result += digits[num/100] + " Hundred ";
            num %= 100;
        }

        if (num >= 20) {
            result += tens[num / 10] + " ";
            num %= 10;
        }

        if (num >= 1 && num <= 19)
            result += digits[num];

        // remove tailing spaces
        if (isspace(result.back()))
            result.resize(result.size() - 1);

        return result;

    }
};
```

274 H-Index
------

H-Indexçš„å®šä¹‰ï¼šä¸€ä¸ªç§‘å­¦å®¶çš„Nç¯‡è®ºæ–‡hä¸ªè‡³å°‘æœ‰hä¸ªå¼•ç”¨ï¼Œè€Œä¸”å‰©ä¸‹çš„N-hç¯‡è®ºæ–‡éƒ½æ²¡æœ‰è¶…è¿‡hä¸ªå¼•ç”¨ã€‚

```C
int hIndex(int* cites, int n) {
    int hs[n+1]; // Hindexä¸å¯èƒ½å¤§äºN

    for (int i = 0; i <= n; i++)
        hs[i] = 0;

    for (int i = 0; i < n; i++) {
        if (cites[i] > n)
            hs[n]++;
        else
            hs[cites[i]]++;
    }

    for (int i = n, papers = 0; i >= 0; i--) { // ä»åå¾€å‰ï¼Œå¦‚æœæœ‰ç¬¦åˆæ¡ä»¶çš„ï¼Œé‚£ä¹ˆå°±æ˜¯Hindex
        papers += hs[i];
        if (papers >= i)
            return i;
    }

    return 0;
}
```

275 H-index IIï¼Œè®ºæ–‡å·²ç»æŒ‰ç…§å¼•ç”¨æ•°é‡æ’åº
------

```C
int hIndex(int* citations, int n) {
    int left = 0, right = n - 1;
    while (left <= right) { // äºŒåˆ†æŸ¥æ‰¾æ˜¯å°äºç­‰äº
        int mid = left + (right - left) / 2;
        if (citations[mid] == n - mid)
            return citations[mid];
        else if (citations[mid] < n - mid)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return n - right - 1;
}
```

276-277 Locked

278 ç¬¬ä¸€ä¸ªåç‰ˆæœ¬
------

```C
// å®é™…ä¸Šæ˜¯lower_boundå‡½æ•°
int firstBadVersion(int n) {
    int left = 0, right = n; // è®°ä½lower_boundçš„rightæ˜¯n
    while (left < right) {   // ä½¿ç”¨å°äºå·
        int mid = left + (right - left) / 2;
        if (!isBadVersion(mid))
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}
```

279 åˆ†è§£ä¸ºå¹³æ–¹æ•°çš„å’Œ
------

æœ€å¤š4ä¸ªå³å¯ï¼Œå°è¯•åœ¨ä¸‰ä¸ªä»¥å†…æ˜¯å¦å¯ä»¥ã€‚

```C
int numSquares(int n) {
    int ub = sqrt(n);
    for (int a=0; a<=ub; ++a) {
        for (int b=a; b<=ub; ++b) {
            int c = sqrt(n - a*a - b*b);
            if (a*a + b*b + c*c == n)
                return !!a + !!b + !!c;
        }
    }
    return 4;
}
```

282 æ·»åŠ è¿ç®—ç¬¦ä½¿å¾—ç®—å¼æˆç«‹
------

```C++
vector<string> addOperators(string num, int target) {
    vector<string> result;
    if (num.size() == 0)
        return result;
    dfs(num, target, result, num[0] - '0', num.substr(0, 1), 1, 1);
    return result;
}

void dfs(string num, int target, vector<string> & v, long long last, string s, int idx, int left) {
    if (idx == num.length()){
        if (target == last*left)
            v.push_back(s);
        return;
    } else {
        if(last!=0)
            dfs(num, target,         v, last * 10 + num[idx] - '0', s + num.substr(idx, 1), idx + 1, left); // å°è¯•æ‹¼æˆ10
        dfs(num, target,             v, num[idx] - '0', s + '*' + num.substr(idx, 1), idx + 1, last*left);
        dfs(num, target - left*last, v, num[idx] - '0', s + '+' + num.substr(idx, 1), idx + 1, 1);
        dfs(num, target - left*last, v, num[idx] - '0', s + '-' + num.substr(idx, 1), idx + 1, -1);
    }
}
```

283 ç§»åŠ¨0
------

æ³¨æ„swapçš„ä½¿ç”¨

```C++
void moveZeroes(vector<int>& nums) {
    int n = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0)
            swap(nums[n++], nums[i]);
    }
}
```

284 Peek Iterator
------

```C++
// Below is the interface for Iterator, which is already defined for you.
// **DO NOT** modify the interface for Iterator.
class Iterator {
    struct Data;
    Data* data;
public:
    Iterator(const vector<int>& nums);
    Iterator(const Iterator& iter);
    virtual ~Iterator();
    // Returns the next element in the iteration.
    int next();
    // Returns true if the iteration has more elements.
    bool hasNext() const;
};


class PeekingIterator : public Iterator {
public:
    PeekingIterator(const vector<int>& nums) : Iterator(nums) {
        // Initialize any member here.
        // **DO NOT** save a copy of nums and manipulate it directly.
        // You should only use the Iterator interface methods.

    }

    // Returns the next element in the iteration without advancing the iterator.
    int peek() {
        return Iterator(*this).next();
    }

    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    int next() {
        return Iterator::next();
    }

    bool hasNext() const {
        return Iterator::hasNext();
    }
};
```

285 ~ 286 Locked
------

287 ä¸€ä¸ªnçš„æ•°ç»„åŒ…å«äº†1...n-1ä¸­çš„è¿™äº›æ•°å­—ï¼Œè¯æ˜ä¸€å®šå­˜åœ¨é‡å¤ï¼Œå¹¶æ‰¾å‡ºè¿™ä¸ªé‡å¤
------

ä½¿ç”¨æŠ½å±‰åŸç†å¯ä»¥è¯æ˜ä¸€å®šå­˜åœ¨é‡å¤ã€‚æ®è¯´é«˜çº³å¾·è§£è¿™ä¸ªé—®é¢˜èŠ±äº†å››ä¸ªå°æ—¶ã€‚

æˆ‘ä»¬æŠŠè¿™ä¸ªæ•°ç»„çœ‹åšä¸€ä¸ªå˜å¹»æ–¹ç¨‹ `f(i) = A[i]`ï¼ŒæŠŠä¸€äº›æ•°å­—å˜å¹»åˆ°å¦ä¸€äº›ï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ª `i != j s.t. f(i) == f(j)`.
é‚£ä¹ˆè¿™ä¸ªé—®é¢˜å˜æˆäº†é“¾è¡¨æ±‚ç¯çš„é—®é¢˜ã€‚å¯¹äºé“¾è¡¨ï¼Œæˆ‘ä»¬æœ‰ n = n->next éå†åˆ—è¡¨ï¼Œå¯¹äºè¿™ä¸ªåºåˆ—ï¼Œåˆ™æ˜¯` n = f(n)`

```C
int findDuplicate(int* nums, int n) {
    // ä» n-1 å¼€å§‹
    int fast = n - 1, slow = n - 1;
    do {
        slow = nums[slow] - 1; // å‡ä¸€æ˜¯ä¸ºäº†è½¬åŒ–ä¸ºåæ ‡
        fast = nums[nums[fast] - 1] - 1;
    } while (slow != fast);

    fast = n - 1;
    do {
        slow = nums[slow] - 1;
        fast = nums[fast] - 1;
    } while (slow != fast);

    return slow + 1; // ä»åæ ‡åˆ°æ•°å­—
}
```

288 Locked
------

289 Conway's Game of Life
------

å“ˆå“ˆï¼Œæœºæ™ºï¼Œä½¿ç”¨æ²¡æœ‰ä½¿ç”¨çš„ç¬¬äºŒä¸ªä½å­˜å‚¨ä¸‹ä¸€ä»£

```C
int max(int a, int b) {return a > b ? a :b;}
int min(int a, int b) {return a < b ? a :b;}
void gameOfLife(int** board, int row, int col) {
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            int count = 0;
            for (int m=max(i-1, 0); m<min(i+2, row); m++) // è¿™é‡Œçš„minï¼Œmaxä½¿ç”¨çš„å¤ªå±Œäº†
                for (int n=max(j-1, 0); n<min(j+2, col); n++)
                    count += (board[m][n] & 1);
            if (count == 3 || count - board[i][j] == 3) // å½“å‰ä¸º0ï¼Œå‘¨å›´ä¸º3ï¼›or å½“å‰ä¸º1ï¼Œå‘¨å›´ä¸º2/3 here
                board[i][j] |= 2;
        }
    }
    for (int i = 0; i < row; i++)
        for (int j = 0; j < col; j++)
            board[i][j] >>= 1;
}
```

290 å•è¯æ¨¡å¼ï¼Œç»™å®šä¸€ä¸ªæ¨¡å¼abbaç­‰ï¼Œåˆ¤æ–­å•è¯æ˜¯å¦æ˜¯è¿™ä¸ªæ¨¡å¼çš„ã€‚
------

```C++
bool wordPattern(string pattern, string str) {
    map<char, int> chars;  // ä½¿ç”¨ä¸¤ä¸ªmapçºªå½•
    map<string, int> words;
    istringstream in(str);
    int i = 0, n = pattern.size(); // `i` is word count
    for (string word; in >> word; i++) {
        if (i == n || chars[pattern[i]] != words[word]) // æ£€æŸ¥æ˜¯å¦ç›¸ç­‰
            return false;
        chars[pattern[i]] = words[word] = i + 1; // distinct non zero
    }

    return i == n; // æ£€æŸ¥é•¿åº¦æ˜¯å¦ç›¸ç­‰
}
```

291 Locked
------

292 Nimæ¸¸æˆï¼Œæ¯ä¸ªäººå¯ä»¥é€‰æ‹©ä¸¢æ‰1ï¼Œ2ï¼Œ3ï¼Œæœ€åä¸€ä¸ªæ“ä½œè€…è·èƒœ
------

æ˜¾ç„¶ï¼Œå½“æˆ‘ä»¬é‡åˆ°4çš„æ—¶å€™ä¼šè¾“ï¼Œå…¶ä»–æƒ…å†µéƒ½å¯ä»¥èµ¢ã€‚

```C
bool canWinNim(int n) {
    return n % 4 != 0;
}
```

344 ç¿»è½¬å­—ç¬¦ä¸²
------

```C
char* reverseString(char* s) {
    char* start = s;
    char* e = s;
    while (*e) ++e;
    e--;
    char t;
    while (s < e) {
        t = *s;
        *s = *e;
        *e = t;
        s++;
        e--;
    }
    return start;
}
```

347 å‡ºç°æœ€å¤šçš„å‡ ä¸ªæ•°å­—
------

C å®åœ¨ç¼ºä¹ç›¸å…³çš„åŸºç¡€æ•°æ®ç»“æ„ï¼Œè¿™é“é¢˜ç”¨ JS åšäº†

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
let topKFrequent = function(nums, k) {
    let counter = {};
    for (let num of nums) {
        if (num in counter) {
            counter[num]++;
        } else {
            counter[num] = 0;
        }
    }

    let bucket = [];
    for (let num in counter) {
        let rev_freq = nums.length - counter[num] + 1;
        if (rev_freq in bucket) {
            bucket[rev_freq].push(num);
        } else {
            bucket[rev_freq] = [num];
        }
    }

    let rv = [];
    for (let bc of bucket) {
        if (! Array.isArray(bc)) continue;
        for (let num of bc) {
            if (rv.length == k)
                return rv;
            else
                rv.push(parseInt(num))
        }
    }

    return rv;
};
```

349 ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å‡ºç°çš„å…ƒç´ 
------

å…ˆæ’åºï¼Œé™ä½å¤æ‚åº¦

```C
static int compare(const void* a, const void* b) {
    return *(int*)a - *(int*)b;
}
int* intersection(int* A, int m, int* B, int n, int* k) {
    qsort(A, m, sizeof(int), compare);
    qsort(B, n, sizeof(int), compare);
    int* C = malloc((m + n) * sizeof(int));
    *k = 0;
    int i = 0;
    int j = 0;
    while (i < m && j < n) {
        if (A[i] == B[j]) {
            if (*k == 0)
                C[(*k)++] = A[i];
            else if (C[*k - 1] != A[i])
                C[(*k)++] = A[i];
            i++;
            j++;
        } else if (A[i] < B[j]) {
            i++;
        } else {
            j++;
        }
    }
    return C;
}
```


345 ç¿»è½¬ä¸€ä¸ªå­—ç¬¦ä¸²é‡Œé¢çš„å…ƒéŸ³å­—æ¯
------

ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸è¿‡éœ€è¦æ³¨æ„å…ƒéŸ³å­—æ¯åŒ…æ‹¬äº†å¤§å°å†™

```Python
class Solution:
    def reverseVowels(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return s
        vowels = set("AEIOUaeiou")
        s = list(s)
        i = 0
        j = len(s) - 1
        while True:
            while s[i] not in vowels and i < j:
                i += 1
            while s[j] not in vowels and i < j:
                j -= 1
            if i >= j:
                break
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1
        return ''.join(s)
```

371 ä¸¤ä¸ªæ•°ä¹‹å’Œ
------

è¿™é“é¢˜è¦æ±‚ä¸ç”¨+å’Œ-æ¥è®¡ç®—å‡ºä¸¤ä¸ªæ•°ä¹‹å’Œï¼Œæ˜¾ç„¶åº”è¯¥ä½¿ç”¨ä½è¿ç®—ï¼Œä½¿ç”¨å¼‚æˆ–è®¡ç®—æ¯ä¸€ä½çš„å€¼ï¼Œåœ¨ä½¿ç”¨æˆ–è®¡ç®—æ˜¯å¦éœ€è¦è¿›ä½

```C
int getSum(int a, int b) {
    int rv = 0;
    int carry = 0;

    for (int i = 0; i < 32; i++) {
        int last_bit_of_a = a & 1;
        int last_bit_of_b = b & 1;

        rv |= (last_bit_of_a ^ last_bit_of_b ^ carry) << i;
        carry = (carry & last_bit_of_a) | (carry & last_bit_of_b) | (last_bit_of_a & last_bit_of_b);

        a >>= 1;
        b >>= 1;
    }

    return rv;
}
```

904 æ‰¾å‡ºåŒ…å«äº†ä¸¤ä¸ªä¸åŒæ•°å­—çš„æœ€é•¿å­åºåˆ—
------

è¿™é“é¢˜çš„é¢˜ç›®å¾ˆå‘çˆ¹,ä½†æ˜¯ç¿»è¯‘è¿‡æ¥å…¶å®è¦æ±‚å¾ˆæ˜ç¡®. è§£é¢˜æ€è·¯ä¹Ÿå¾ˆç®€å•, å­˜å‚¨ä¸€ä¸‹å½“å‰çš„æœ€é•¿åºåˆ—
å°±å¥½äº†.

```C++
```

```Rust
use std::collections::HashMap;
use std::cmp::max;

impl Solution {
    pub fn total_fruit(tree: Vec<i32>) -> i32 {
        let mut i = 0;
        let mut res = 0;
        let mut counter = HashMap::new();
        for (j, el) in tree.iter().enumerate() {
            *counter.entry(el).or_insert(0) += 1;
            while counter.len() > 2 {
                *counter.get_mut(&tree[i]).unwrap() -= 1;
                if let Some(x) = counter.get(&tree[i]) {
                    if *x == 0 {
                        counter.remove(&tree[i]);
                    }
                }
                i += 1;
            }
            res = max(res, j - i + 1);
        }
        res as i32
    }
}
```
